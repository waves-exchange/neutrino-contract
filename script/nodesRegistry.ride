{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
let MULT6 = 1_000_000
let MULT8 = 1_0000_0000

let WAVESIDSTR = "WAVES"
let WAVESID    = fromBase58String(WAVESIDSTR)

func getIntOrFail(key: String) = {
  this.getInteger(key).valueOrErrorMessage("Mandatory this." + key + " is not defined")
}

func getStrOrElse(key: String, defaultVal: String) = {
  this.getString(key).valueOrElse(defaultVal)
}

func getStringOrFail(address: Address, key: String) = {
  address.getString(key).valueOrErrorMessage("Mandatory this." + key + " is not defined")
}

func getAddressOrFail(key: String) = {
  this.getStringOrFail(key).addressFromString().valueOrErrorMessage("Fail to convert this." + key + " value into Address")
}

func validateAddressOrFail(addressStr: String) = {
  let address = addressStr.addressFromString().valueOrErrorMessage("fail to convert into address " + addressStr)
  if (wavesBalance(address).available < 0) then throw() else addressStr
}

func keyNodeRegistry(address: String)       = "%s__" + address
func keyNodeRewardsTotals(address: String)  = "%s%s__totals__" + address
func keyApprovedNodeList()                  = "%s__approvedNodeList"
func keyDepositAmount()                     = "%s%s__cfg__depositAmount"
func keyNeutrinoAddressStr()                = "%s%s__cfg__neutrinoAddress"
func keyMasterNodeAddressStr()              = "%s%s__cfg__mainNeutrinoNodeAddress"
func keyProtocolPartX6()                    = "%s%s__cfg__protocolPartX6"
func keyBenificaryPartX6()                  = "%s%s__cfg__benificaryPartX6"
func keyMinDistributeAmount()               = "%s%s__cfg__minDistributeAmount"

# miningNode KEYs
func keyBeneficiaryAddress()  = "%s%s__cfg__beneficiaryAddress"

func formatDepositAdd(txIdStr: String, depositAmount: Int, remainingDepositAmount: Int, status: String) = {
  ["%s%d%d%d%d%s%d%d",
      txIdStr,
      lastBlock.height.toString(),
      lastBlock.timestamp.toString(),
      depositAmount.toString(),
      remainingDepositAmount.toString(),
      status,
      "0", # status changed block
      "0"  # status changed timestamp
  ].makeString(SEP)
}

func formatDepositChangeStatus(origS: String, newStatus: String) = {
  let orig = origS.split(SEP)
  ["%s%d%d%d%d%s%d%d",
      orig[1],
      orig[2],
      orig[3],
      orig[4],
      orig[5],
      newStatus,
      lastBlock.height.toString(),    # status changed block
      lastBlock.timestamp.toString()  # status changed timestamp
  ].makeString(SEP)
}

func keyRewardHistory(nodeAddress: Address, txId: ByteVector) = {
  ["%s%s%s",
      "history",
      nodeAddress.toString(),
      txId.toBase58String()
  ].makeString(SEP)
}

func dataRewardHistory(wavesAmountTotal: Int, beneficiaryAmt: Int, protocolAmt: Int, protocolAmtPart1: Int, protocolAmtPart2: Int) = {
  ["%d%d%d%d%d%d%d",
      lastBlock.height.toString(),
      lastBlock.timestamp.toString(),
      wavesAmountTotal.toString(),
      beneficiaryAmt.toString(),
      protocolAmt.toString(),
      protocolAmtPart1.toString(),
      protocolAmtPart2.toString()
  ].makeString(SEP)
}

func RewardHistoryEntry(nodeAddress: Address, txId: ByteVector, minedAmt: Int, beneficiaryAmt: Int, protocolAmt: Int, protocolAmt1: Int, protocolAmt2: Int) = {
  StringEntry(
      keyRewardHistory(nodeAddress, txId),
      dataRewardHistory(minedAmt, beneficiaryAmt, protocolAmt, protocolAmt1, protocolAmt2))
}

func dataRewardTotals(minedAmt: Int, beneficiaryAmt: Int, protocolAmt: Int, protocolAmtPart1: Int, protocolAmtPart2: Int) = {
  ["%d%d%d%d%d",
      minedAmt.toString(),
      beneficiaryAmt.toString(),
      protocolAmt.toString(),
      protocolAmtPart1.toString(),
      protocolAmtPart2.toString()
  ].makeString(SEP)
}

func RewardTotalsEntry(miner: Address, minedAmt: Int, beneficiaryAmt: Int, protocolAmt: Int, protocolAmtPart1: Int, protocolAmtPart2: Int) = {
  let nodeRewardsTotalsKEY = keyNodeRewardsTotals(miner.toString())
  let nodeRewardsArray = nodeRewardsTotalsKEY.getStrOrElse(dataRewardTotals(0, 0, 0, 0, 0)).split(SEP)

  let newMinedAmt         = nodeRewardsArray[1].parseIntValue() + minedAmt
  let newBeneficiaryAmt   = nodeRewardsArray[2].parseIntValue() + beneficiaryAmt
  let newProtocolAmt      = nodeRewardsArray[3].parseIntValue() + protocolAmt
  let newProtocolAmtPart1 = nodeRewardsArray[4].parseIntValue() + protocolAmtPart1
  let newProtocolAmtPart2 = nodeRewardsArray[5].parseIntValue() + protocolAmtPart2

  StringEntry(
      nodeRewardsTotalsKEY,
      dataRewardTotals(newMinedAmt, newBeneficiaryAmt, newProtocolAmt, newProtocolAmtPart1, newProtocolAmtPart2)
  )
}

func resolveBeneficiaries(minerAddress: Address, beneficiaryFromParam: Address) = {
  let minerScriptHash = scriptHash(minerAddress)

  let beneficiaryFromMinerState = minerAddress.getStringOrFail(keyBeneficiaryAddress()).addressFromStringValue()

  if (minerScriptHash == unit) then beneficiaryFromParam else beneficiaryFromMinerState
}

@Callable(i)
func constructor(depositAmount: Int, neutrinoAddressStr: String, masterNodeAddressStr: String, protocolPartX6: Int, benificaryPartX6: Int) = {
  if (i.caller != this) then throw("permissions denied") else
  if (depositAmount < 0) then throw("depositAmount less then zero") else
  if (protocolPartX6 < 0) then throw("protocolPartX6 less then zero") else
  if (benificaryPartX6 < 0) then throw("benificaryPartX6 less then zero") else
  if ((protocolPartX6 + benificaryPartX6) != MULT6) then throw("parts sum must be 1") else

  [IntegerEntry(keyDepositAmount(), depositAmount),
    StringEntry(keyNeutrinoAddressStr(), neutrinoAddressStr.validateAddressOrFail()),
    StringEntry(keyMasterNodeAddressStr(), masterNodeAddressStr.validateAddressOrFail()),
    IntegerEntry(keyProtocolPartX6(), protocolPartX6),
    IntegerEntry(keyBenificaryPartX6(), benificaryPartX6)
  ]
}

@Callable(i)
func sumbitApplication() = {
  if (i.payments.size() != 1) then throw("exact 1 payment must be attached") else
  if (i.caller != i.originCaller) then throw("dapp to dapp calls are not allowed") else
  let pmt = i.payments[0]
  let deposit = pmt.amount
  let pmtAssetId = pmt.assetId.valueOrElse(WAVESID)

  let expectedDepositAmount = keyDepositAmount().getIntOrFail()
  let txId = i.transactionId.toBase58String()
  let nodeAddress = i.caller.toString()
  let nodeRegistryKEY = keyNodeRegistry(nodeAddress)

  if (pmtAssetId != WAVESID) then throw("only Waves can be used for deposit") else
  if (deposit != expectedDepositAmount) then throw("exactly " + expectedDepositAmount.toString() + " Wavelets are expected") else
  if (nodeRegistryKEY.getStrOrElse("") != "") then throw("your node already registered") else

  [StringEntry(nodeRegistryKEY, formatDepositAdd(txId, deposit, deposit, "PENDING"))]
}

@Callable(i)
func distributeMinerReward(beneficiaryAddressStr: String) = {
  let minDistributeAmount = this.getInteger(keyMinDistributeAmount()).valueOrElse(24 * MULT8)
  if (i.payments.size() != 1) then throw("exact 1 payment must be attached") else
  if (i.caller != i.originCaller) then throw("dapp to dapp calls are not allowed") else
  let pmt = i.payments[0]
  let pmtAssetId = pmt.assetId.valueOrElse(WAVESID)
  let feeAmt = i.fee
  let feeAssetId = i.feeAssetId.valueOrElse(WAVESID)

  let callReward = feeAmt * 3
  let minedAmt = pmt.amount - callReward

  if (pmt.amount < minDistributeAmount) then throw("attached payment is less then min " + minDistributeAmount.toString() + " Wavelets") else
  if (pmtAssetId != WAVESID) then throw("only Waves can be used in payment") else
  if (feeAssetId != WAVESID) then throw("only Waves can be used in fees") else
  if (feeAmt != 5 * MULT8 / 1000) then throw("fee amount couldn't exceed 0.005") else
  let neutrinoAddress = keyNeutrinoAddressStr().getAddressOrFail()
  let masterNodeAddress = keyMasterNodeAddressStr().getAddressOrFail()

  let minerAddress = i.caller
  let beneficiaryFromParam = beneficiaryAddressStr.addressFromStringValue()

  let beneficiaryAddress = resolveBeneficiaries(minerAddress, beneficiaryFromParam)
  let txRewardReceiver   = beneficiaryFromParam

  let protocolPart    = keyProtocolPartX6().getIntOrFail()
  let beneficiaryPart  = keyBenificaryPartX6().getIntOrFail()

  let availableBalance = wavesBalance(minerAddress).available - feeAmt
  if (availableBalance != 0) then throw("all " + availableBalance.toString() + " Wavelets from the Node balance must be attached into the payment") else

  let beneficiaryAmt = fraction(minedAmt, beneficiaryPart, MULT6)
  let protocolAmt = minedAmt - beneficiaryAmt
  let protocolAmt1 = protocolAmt / 2
  let protocolAmt2 = protocolAmt - protocolAmt1

  [ScriptTransfer(beneficiaryAddress,    beneficiaryAmt, unit),
    ScriptTransfer(neutrinoAddress,     protocolAmt1,  unit),
    ScriptTransfer(masterNodeAddress,   protocolAmt2,  unit),
    ScriptTransfer(txRewardReceiver,  callReward,    unit),
    RewardHistoryEntry(minerAddress, i.transactionId, minedAmt, beneficiaryAmt, protocolAmt, protocolAmt1, protocolAmt2),
    RewardTotalsEntry(minerAddress, minedAmt, beneficiaryAmt, protocolAmt, protocolAmt1, protocolAmt2)
  ]
}

@Callable(i)
func validateAndApproveLeasings(nListS: String) = {
  let nIdxs = [0, 1, 2, 3, 4, 5, 6, 7]

  let nList = nListS.split(SEP)
  let expectedCount = nIdxs.size()

  let neutrinoAddress = keyNeutrinoAddressStr().getAddressOrFail()

  if (i.caller != neutrinoAddress) then throw("validateAndApproveLeasings not authorized") else
  if (nList.size() % 2 != 0) then throw("Only even number of nodes is allowed") else
  if (nList.size() != expectedCount) then throw("Only " + expectedCount.toString() + " node's address cab be passed") else

  func forEachNodeChangeStatus(acc: List[StringEntry], i: Int) = {
    let nodeAddr = nList[i]
    let nodeRegistryKEY = keyNodeRegistry(nodeAddr)
    let nodeDataOpt = this.getString(nodeRegistryKEY)
    if (!nodeDataOpt.isDefined()) then throw("invalid Node in list " + nodeAddr) else
    let nodeData = nodeDataOpt.value().split(SEP)
    let nodeStatus = nodeData[6]
    if (nodeData.size() >= 9 && nodeStatus != "PENDING") then throw("node " + nodeAddr + " already has a final status " + nodeStatus) else
    acc
      :+ StringEntry(nodeRegistryKEY, formatDepositChangeStatus(nodeDataOpt.value(), "APPROVED"))
  }

  let approvedNodesData = FOLD<8>(nIdxs, [], forEachNodeChangeStatus)
  (approvedNodesData, nil)
}

@Callable(i)
func returnDeposit(nodeAddressStr: String) = {
  if (i.payments.size() != 0) then throw("No payments allowed") else
  let callerAddress = i.caller
  let nodeAddress = nodeAddressStr.addressFromStringValue()
  let approvedNodeList = this.getStringOrFail(keyApprovedNodeList())

  if (callerAddress != this && nodeAddress != callerAddress) then throw("returnDeposit permissions denied") else
  let nodeRegistryKEY = keyNodeRegistry(nodeAddressStr) # "%s__" + address
  let nodeDataOpt = this.getString(nodeRegistryKEY)
  if (!nodeDataOpt.isDefined()) then throw("Address is not applied as neutrino node: " + nodeAddressStr) else
  if (approvedNodeList.contains(nodeAddressStr)) then throw("Impossible to return deposit from approved Node, please contact support team") else

  let nodeData = nodeDataOpt.value().split(SEP)
  let status = if (nodeData.size() >= 9) then nodeData[6] else "PENDING"
  if (status != "PENDING") then throw("Application status is not PENDING!") else

  let depoAmount = nodeData[4].parseIntValue()

  let beneficiaryAddress = resolveBeneficiaries(nodeAddress, nodeAddress)
  [DeleteEntry(nodeRegistryKEY), ScriptTransfer(beneficiaryAddress, depoAmount,  unit)]
}
