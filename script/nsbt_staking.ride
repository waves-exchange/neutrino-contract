{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# NSBT Staking Smart Contract

let revisionNum = ""
let separator = "__"
let SCALE = 1000
let MULT8 = 1_0000_0000
let HALF8 = 5000_0000

# Neutrino Contract Keys
func keyBondAsset() = "bond_asset_id"
func keyAuctionContractAddress() = "auction_contract"

# NSBT Lock Contract Keys
func keyNeutrinoContractAddress() = "%s__neutrinoContractAddress"
func keyMinLockAmount() = "%s__minLockAmount"
func keyHalfLife() = "%s__halfLife"
# Lock Params
func keyLockParamUserAmount(userAddress: Address) = ["%s%s%s", "paramByUser", userAddress.toString(), "amount"].makeString(separator)
func keyLockParamStartBlock(userAddress: Address) = ["%s%s%s", "paramByUser", userAddress.toString(), "start"].makeString(separator)
# History
func keyHistoryRecord(type: String, userAddress: Address, txId: ByteVector) = ["%s%s%s%s", "history", type, userAddress.toString(), txId.toBase58String()].makeString(separator)
# Stats
func keyLockParamTotalAmount() = ["%s%s", "stats", "activeTotalLocked"].makeString(separator)
func keyStatsLocksCount() = ["%s%s", "stats", "locksCount"].makeString(separator)
func keyStatsUsersCount() = ["%s%s", "stats", "activeUsersCount"].makeString(separator)

# Reward Payouts Distribution Keys
func keyNextPeriod() = "%s__nextPeriod"

func getIntOrZero(key: String) = {
  this.getInteger(key).valueOrElse(0)
}

func getIntOrFail(key: String) = {
  this.getInteger(key).valueOrErrorMessage("Mandatory this." + key + " is not defined")
}

func getStringOrFail(key: String) = {
  this.getString(key).valueOrErrorMessage("Mandatory this." + key + " is not defined")
}

func formatHistoryRecord(oldAmount: Int, oldStart: Int, newAmount: Int, newStart: Int) = {
  [
    "%d%d%d%d%d%d",
    lastBlock.height.toString(),
    lastBlock.timestamp.toString(),
    oldAmount.toString(),
    oldStart.toString(),
    newAmount.toString(),
    newStart.toString()
  ].makeString(separator)
}

func HistoryRecordEntry(type: String, userAddress: Address, txId: ByteVector, 
    oldAmount: Int, oldStart: Int, newAmount: Int, newStart: Int) = {
  StringEntry(
    keyHistoryRecord(type, userAddress, txId),
    formatHistoryRecord(oldAmount, oldStart, newAmount, newStart)
  )
}

func StatsEntry(totalLockedInc: Int, lockCountInc: Int, usersCountInc: Int) = {
  let locksCount = keyStatsLocksCount().getIntOrZero()
  let usersCount = keyStatsUsersCount().getIntOrZero()
  let totalAmount = keyLockParamTotalAmount().getIntOrZero()

  [
    IntegerEntry(keyStatsLocksCount(), locksCount + lockCountInc),
    IntegerEntry(keyStatsUsersCount(), usersCount + usersCountInc),
    IntegerEntry(keyLockParamTotalAmount(), totalAmount + totalLockedInc)
  ]
}

func LockParamsEntry(userAddress: Address, amount: Int, start: Int) = {
  [
    IntegerEntry(userAddress.keyLockParamUserAmount(), amount),
    IntegerEntry(userAddress.keyLockParamStartBlock(), start)
  ]
}

func getParamsOrFail() = {
  let neutrinoContract = keyNeutrinoContractAddress().getStringOrFail().addressFromStringValue()
  (
    neutrinoContract.getStringValue(keyAuctionContractAddress()).fromBase58String(),
    neutrinoContract.getStringValue(keyBondAsset()).fromBase58String(),
    keyMinLockAmount().getIntOrFail(),
    keyHalfLife().getIntOrFail()
  )
}

func isUserExists(userAddress: Address) = {
  this.getInteger(userAddress.keyLockParamStartBlock()).isDefined()
}

func getUserParamsOrUnit(userAddress: Address) = {
  if (userAddress.isUserExists()) then {
    (
      userAddress.keyLockParamUserAmount().getIntOrFail(),
      userAddress.keyLockParamStartBlock().getIntOrFail()
    )
  } else unit
}

func getUserParamsOrFail(userAddress: Address) = {
  userAddress.getUserParamsOrUnit().valueOrErrorMessage("User " + userAddress.toString() + " is not defined")
}

# find out merged stake effective height
func mergedHeight(amount1: Int, height1: Int, amount2: Int, height2: Int, halfLife: Int) = {
  let w = fraction(amount2, pow(2, 0, fraction(height2 - height1, MULT8, halfLife), 8, 8, HALFUP), MULT8)
  let v = fraction(amount1 + amount2, MULT8, amount1 + w)
  height1 + (HALF8 - halfLife * log(v, 8, 2, 0, 8, HALFUP)) / MULT8
}

func getUnstakeComissionAmount(amount: Int, startHeight: Int, halfLife: Int) = {
  fraction(amount, pow(2, 0, fraction(-(height - startHeight), MULT8, halfLife), 8, 8, HALFUP), MULT8)
}

# init halfLife with 259200
@Callable(i)
func constructor(neutrinoContractAddress: String, minLockAmount: Int, halfLife: Int) = {
  if (i.caller != this) then throw("Permission denied") else
  [
    StringEntry(keyNeutrinoContractAddress(), neutrinoContractAddress),
    IntegerEntry(keyMinLockAmount(), minLockAmount),
    IntegerEntry(keyHalfLife(), halfLife)
  ]
}

@Callable(i)
func stake() = {
  let (auctionContract, bondAssetId, minLockAmount, halfLife) = getParamsOrFail()
  if (i.payments.size() != 1) then throw("Invalid payments size") else
  let payment = i.payments[0]
  let amount = payment.amount

  let invalidAssetMessage = "Invalid asset. " + bondAssetId.toBase58String() + " is expected"
  let assetId = payment.assetId.valueOrErrorMessage(invalidAssetMessage)
  if (assetId != bondAssetId) then throw(invalidAssetMessage) else

  let userAddress = i.caller
#  if (userAddress.scriptHash().isDefined()) then throw("Address is scripted. Access denied") else

  let (isNewUser, lockAmount, lockStartHeight) = match userAddress.getUserParamsOrUnit() {
    case p: (Int, Int) => (false, p._1, p._2)
    case _: Unit => (true, 0, -1)
  }

  let mergedAmount = if (isNewUser) then amount else amount + lockAmount
  let mergedStartHeight = if (isNewUser) then height else mergedHeight(amount, height, lockAmount, lockStartHeight, halfLife)
  if (mergedAmount < minLockAmount) then throw("Min lock amount is " + minLockAmount.toString()) else

  [
    HistoryRecordEntry("stake", userAddress, i.transactionId, lockAmount, lockStartHeight, mergedAmount, mergedStartHeight)
  ]
  ++ LockParamsEntry(userAddress, mergedAmount, mergedStartHeight)
  ++ StatsEntry(amount, 1, if (isNewUser) then 1 else 0)
}

@Callable(i)
func unstake(amount: Int) = {
  let userAddress  = i.caller
  let (auctionAddress, bondAssetId, minLockAmount, halfLife) = getParamsOrFail()
  let (lockAmount, lockStart) = userAddress.getUserParamsOrFail()

  if (lockAmount <= 0) then throw("Nothing to unstake") else
  if (amount > lockAmount) then throw("Requested " + amount.toString() + ", but staked only " + lockAmount.toString()) else

  let comissionAmount = getUnstakeComissionAmount(amount, lockStart, halfLife)
  [
    ScriptTransfer(userAddress, amount - comissionAmount, bondAssetId),
    ScriptTransfer(auctionAddress.Address(), comissionAmount, bondAssetId),
    HistoryRecordEntry("unstake", userAddress, i.transactionId, lockAmount, lockStart, lockAmount - amount, lockStart)
  ]
  ++ LockParamsEntry(userAddress, lockAmount - amount, lockStart)
  ++ StatsEntry(-amount, if (amount == lockAmount) then -1 else 0, if (amount == lockAmount) then -1 else 0)
}

# User's gNSBT amount
@Callable(i)
func gNsbtAmountREADONLY(userAddressStr: String) = {
  let userAddress = userAddressStr.addressFromStringValue()
  (
    [],
    if (userAddress.isUserExists()) then userAddress.getUserParamsOrFail()._1 else 0
  )
}

# handle for evaluating merged stake height
@Callable(i)
func mergedHeightREADONLY(amount1: Int, height1: Int, amount2: Int, height2: Int) = {
  let h = mergedHeight(amount1, height1, amount2, height2, keyHalfLife().getIntOrFail())
  ([], h)
}

# Staking params
# (gNsbtAmount, stakingStartHeight)
@Callable(i)
func nsbtStakingInfoWrapperREADONLY(userAddressStr: String) = {
  let (nsbtAmt, stakingStart) = if(userAddressStr == "") then (0,0) else

      let userAddress = userAddressStr.addressFromStringValue()
      if (userAddress.isUserExists()) then {
        let (amount, start) = userAddress.getUserParamsOrFail()
        ([], (amount, start))
      } else ([], (0, 0))

  ([], (nsbtAmt, stakingStart))
}

@Callable(i)
func unstakeComissionAmountREADONLY(amount: Int, startHeight: Int) = {
  let a = getUnstakeComissionAmount(amount, startHeight, keyHalfLife().getIntOrFail())
  ([], a)
}
