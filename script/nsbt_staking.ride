{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# NSBT Staking Smart Contract

let revisionNum = ""
let separator = "__"
let MULT8 = 1_0000_0000

# Neutrino Contract Keys
func keyBondAsset() = "bond_asset_id"
func keyAuctionContractAddress() = "auction_contract"

# NSBT Lock Contract Keys
func keyNeutrinoContractAddress() = "%s__neutrinoContractAddress"
func keyMathContractAddress() = "%s__mathContract"
func keyMinLockAmount() = "%s__minLockAmount"
func keyHalfLife() = "%s__halfLife"
# Lock Params
func keyLockParamUserAmount(userAddress: Address) = ["%s%s%s", "paramByUser", userAddress.toString(), "amount"].makeString(separator)
func keyLockParamStartBlock(userAddress: Address) = ["%s%s%s", "paramByUser", userAddress.toString(), "start"].makeString(separator)
# History
func keyHistoryRecord(type: String, userAddress: Address, txId: ByteVector) = ["%s%s%s%s", "history", type, userAddress.toString(), txId.toBase58String()].makeString(separator)
# Stats
func keyLockParamTotalAmount() = ["%s%s", "stats", "activeTotalLocked"].makeString(separator)
func keyStatsLocksCount() = ["%s%s", "stats", "locksCount"].makeString(separator)
func keyStatsUsersCount() = ["%s%s", "stats", "activeUsersCount"].makeString(separator)

# Reward Payouts Distribution Keys
func keyNextPeriod() = "%s__nextPeriod"

func getIntOrZero(key: String) = {
  this.getInteger(key).valueOrElse(0)
}

func getIntOrFail(key: String) = {
  this.getInteger(key).valueOrErrorMessage("Mandatory this." + key + " is not defined")
}

func getStringOrFail(key: String) = {
  this.getString(key).valueOrErrorMessage("Mandatory this." + key + " is not defined")
}

func asInt(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("fail to cast into Int")
  }
}

func formatHistoryRecord(oldAmount: Int, oldStart: Int, newAmount: Int, newStart: Int) = {
  [
    "%d%d%d%d%d%d",
    lastBlock.height.toString(),
    lastBlock.timestamp.toString(),
    oldAmount.toString(),
    oldStart.toString(),
    newAmount.toString(),
    newStart.toString()
  ].makeString(separator)
}

func HistoryRecordEntry(type: String, userAddress: Address, txId: ByteVector, 
    oldAmount: Int, oldStart: Int, newAmount: Int, newStart: Int) = {
  StringEntry(
    keyHistoryRecord(type, userAddress, txId),
    formatHistoryRecord(oldAmount, oldStart, newAmount, newStart)
  )
}

func StatsEntry(totalLockedInc: Int, lockCountInc: Int, usersCountInc: Int) = {
  let locksCount = keyStatsLocksCount().getIntOrZero()
  let usersCount = keyStatsUsersCount().getIntOrZero()
  let totalAmount = keyLockParamTotalAmount().getIntOrZero()

  [
    IntegerEntry(keyStatsLocksCount(), locksCount + lockCountInc),
    IntegerEntry(keyStatsUsersCount(), usersCount + usersCountInc),
    IntegerEntry(keyLockParamTotalAmount(), totalAmount + totalLockedInc)
  ]
}

func LockParamsEntry(userAddress: Address, amount: Int, start: Int) = {
  [
    IntegerEntry(userAddress.keyLockParamUserAmount(), amount),
    IntegerEntry(userAddress.keyLockParamStartBlock(), start)
  ]
}

func getParamsOrFail() = {
  let neutrinoContract = keyNeutrinoContractAddress().getStringOrFail().addressFromStringValue()
  (
    neutrinoContract.getStringValue(keyAuctionContractAddress()).fromBase58String(),
    neutrinoContract.getStringValue(keyBondAsset()).fromBase58String(),
    keyMinLockAmount().getIntOrFail(),
    keyHalfLife().getIntOrFail()
  )
}

func isUserExists(userAddress: Address) = {
  this.getInteger(userAddress.keyLockParamStartBlock()).isDefined()
}

func getUserParamsOrUnit(userAddress: Address) = {
  if (userAddress.isUserExists()) then {
    (
      userAddress.keyLockParamUserAmount().getIntOrFail(),
      userAddress.keyLockParamStartBlock().getIntOrFail()
    )
  } else unit
}

func getUserParamsOrFail(userAddress: Address) = {
  userAddress.getUserParamsOrUnit().valueOrErrorMessage("User " + userAddress.toString() + " is not defined")
}

# init halfLife with 259200
@Callable(i)
func constructor(neutrinoContractAddress: String, mathContractAddress: String, minLockAmount: Int, halfLife: Int) = {
  if (i.caller != this) then throw("Permission denied") else
  [
    StringEntry(keyNeutrinoContractAddress(), neutrinoContractAddress),
    StringEntry(keyMathContractAddress(), mathContractAddress),
    IntegerEntry(keyMinLockAmount(), minLockAmount),
    IntegerEntry(keyHalfLife(), halfLife)
  ]
}

@Callable(i)
func stake() = {
  let (auctionContract, bondAssetId, minLockAmount, halfLife) = getParamsOrFail()
  if (i.payments.size() != 1) then throw("Invalid payments size") else
  let payment = i.payments[0]
  let amount = payment.amount

  let invalidAssetMessage = "Invalid asset. " + bondAssetId.toBase58String() + " is expected"
  let assetId = payment.assetId.valueOrErrorMessage(invalidAssetMessage)
  if (assetId != bondAssetId) then throw(invalidAssetMessage) else

  let userAddress = i.caller
#  if (userAddress.scriptHash().isDefined()) then throw("Address is scripted. Access denied") else

  let (isNewUser, lockAmount, lockStartHeight) = match userAddress.getUserParamsOrUnit() {
    case p: (Int, Int) => (false, p._1, p._2)
    case _: Unit => (true, 0, -1)
  }

  let mergedAmount = if (isNewUser) then amount else amount + lockAmount

  let mergedStartHeight = if (isNewUser) then height else {
    let mathContract = addressFromStringValue(getStringOrFail(keyMathContractAddress()))
    let hl = keyHalfLife().getIntOrFail()
    mathContract.invoke("mergeStakesREADONLY", [amount, height, lockAmount, lockStartHeight, hl], []).asInt()
  }
  if (mergedAmount < minLockAmount) then throw("Min lock amount is " + minLockAmount.toString()) else

  [
    HistoryRecordEntry("stake", userAddress, i.transactionId, lockAmount, lockStartHeight, mergedAmount, mergedStartHeight)
  ]
  ++ LockParamsEntry(userAddress, mergedAmount, mergedStartHeight)
  ++ StatsEntry(amount, 1, if (isNewUser) then 1 else 0)
}

@Callable(i)
func unstake(amount: Int) = {
  let userAddress  = i.caller
  let (auctionAddress, bondAssetId, minLockAmount, halfLife) = getParamsOrFail()
  let (lockAmount, lockStart) = userAddress.getUserParamsOrFail()

  if (lockAmount <= 0) then throw("Nothing to unstake") else
  if (amount > lockAmount) then throw("Requested " + amount.toString() + ", but staked only " + lockAmount.toString()) else

  let mathContract = addressFromStringValue(getStringOrFail(keyMathContractAddress()))
  let hl = keyHalfLife().getIntOrFail()
  let comissionAmount = mathContract.invoke("getUnstakeComissionAmountREADONLY", [amount, lockStart, hl], []).asInt()
  [
    ScriptTransfer(userAddress, amount - comissionAmount, bondAssetId),
    ScriptTransfer(auctionAddress.Address(), comissionAmount, bondAssetId),
    HistoryRecordEntry("unstake", userAddress, i.transactionId, lockAmount, lockStart, lockAmount - amount, lockStart)
  ]
  ++ LockParamsEntry(userAddress, lockAmount - amount, lockStart)
  ++ StatsEntry(-amount, if (amount == lockAmount) then -1 else 0, if (amount == lockAmount) then -1 else 0)
}