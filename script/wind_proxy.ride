{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
func getStringOrFail(address: Address, key: String) = address.getString(key)
  .valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))

# data index from controlConfig
let IdxControlCfgNeutrinoDapp = 1

let controlAddressKey = "%s%s__config__controlAddress"
let controlCfgKey     = "%s__controlConfig"

func readControlCfgOrFail(control: Address) = split_4C(control.getStringOrFail(controlCfgKey), SEP)
func getContractAddressOrFail(controlCfg: List[String], idx: Int) = controlCfg[idx].addressFromString()
  .valueOrErrorMessage("Control cfg doesn't contain address at index " + idx.toString())

#-------neutrino keys------
func keyWindAssetId()                = "wind_asset_id"

let controlContract = this.getString(controlAddressKey).valueOrElse("3P5Bfd58PPfNvBM2Hy8QfbcDqMeNtzg7KfP").addressFromStringValue()
let controlCfg = controlContract.readControlCfgOrFail()
let neutrinoContract = controlCfg.getContractAddressOrFail(IdxControlCfgNeutrinoDapp)

# WIND pool contract on Puzzle
let windContractKey = "%s__windContract"
let windContract    = this.getString(windContractKey).valueOrElse("3P37uv8V2CMNMtKtwRRNnYPjNqPdGGszytW").addressFromStringValue()
let windAssetIdStr  = neutrinoContract.getStringOrFail(keyWindAssetId())
let windAssetId     = fromBase58String(windAssetIdStr)

func keyWindStaked(stakerAddrStr: String) = stakerAddrStr + "_indexStaked"

# usually rewards are being claimed on each stakeIndex/unstakeIndex operation
# but can be called explicitly
# 10 pool tokens will be collected on this proxy contract
# can be called by anyone, on behalf of this proxy contract
@Callable(i)
func claimIndexRewards() = {
  strict claim = windContract.invoke("claimIndexRewards", [], [])
  ([], 0)
}

# claimIndexRewards will be called inside
# can be called by anyone, on behalf of this proxy contract
@Callable(i)
func stakeIndex() = {
  if (i.payments[0].assetId.value() != windAssetId) then throw("WIND asset should be attached") else
  strict stake = windContract.invoke("stakeIndexFor", [this.toString()], i.payments)
  ([], 0)
}

@Callable(i)
func balanceREADONLY() = {
  let stakedAmt = windContract.getInteger(keyWindStaked(this.toString())).valueOrElse(0) # staked in WIND pool
  ([], stakedAmt)
}

# claimIndexRewards will be called inside
@Callable(i)
func unstakeIndex(indexAmount: Int) = {
  if (i.caller != this && i.caller != neutrinoContract) then throw("Permission denied") else
  if (indexAmount <= 0) then throw("WIND amount can't be negative or zero") else

  strict stake = windContract.invoke("unstakeIndex", [indexAmount], [])
  ([ScriptTransfer(neutrinoContract, indexAmount, windAssetId)], 0)
}

# These calls probably better to do manually:
# generateIndex(true) with 10 payments attached (convert 10 pool assets to WIND)
# generateIndexAndStake with 10 payments attached (convert 10 pool assets to WIND and stake)
# generateIndexWithOneTokenAndStake with payment in WAVES (convert WAVES to WIND and stake)