{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let SEP = "__"
func getStringOrFail(address: Address, key: String) = address.getString(key)
  .valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))

# data index from controlConfig
let IdxControlCfgNeutrinoDapp = 1

let controlAddressKey = "%s%s__config__controlAddress"
let controlCfgKey     = "%s__controlConfig"

func readControlCfgOrFail(control: Address) = split_4C(control.getStringOrFail(controlCfgKey), SEP)
func getContractAddressOrFail(controlCfg: List[String], idx: Int) = controlCfg[idx].addressFromString()
  .valueOrErrorMessage("Control cfg doesn't contain address at index " + idx.toString())

let controlContract = this.getString(controlAddressKey).valueOrElse("3P5Bfd58PPfNvBM2Hy8QfbcDqMeNtzg7KfP").addressFromStringValue()
let controlCfg = controlContract.readControlCfgOrFail()
let neutrinoContract = controlCfg.getContractAddressOrFail(IdxControlCfgNeutrinoDapp)

let beneficiaryAddressKey = "%s__beneficiaryAddress"
let windContractKey = "%s__windContract"
# WIND pool contract on Puzzle
let windContract = this.getString(windContractKey).valueOrElse("3P37uv8V2CMNMtKtwRRNnYPjNqPdGGszytW").addressFromStringValue()
let windAssetId = base58'6TXFMpr6rG4tr2CuPmVRq1NsjgPLJ59s2VMVnL1ZLtpR'

# address to receive rewards
# currently beneficiary is ignored, because Puzzle wind megapool does not pay rewards in WIND token
@Callable(i)
func setBeneficiary(beneficiary: String) = {
  if (i.caller != this) then throw("Permission denied") else
  [StringEntry(beneficiaryAddressKey, beneficiary)]
}

# usually rewards are being claimed on each stakeIndex/unstakeIndex operation
# but can be called explicitly
# 10 pool tokens will be collected on this proxy contract
# can be called by anyone, on behalf of this proxy contract
@Callable(i)
func claimIndexRewards() = {
  strict claim = windContract.invoke("claimIndexRewards", [], [])
  ([], 0)
}

# claimIndexRewards will be called inside
# can be called by anyone, on behalf of this proxy contract
@Callable(i)
func stakeIndex() = {
  if (i.payments[0].assetId.value() != windAssetId) then throw("WIND asset should be attached") else
  strict stake = windContract.invoke("stakeIndexFor", [this.toString()], i.payments)
  ([], 0)
}

# claimIndexRewards will be called inside
@Callable(i)
func unstakeIndex(indexAmount: Int) = {
  if (i.caller != this && i.caller != neutrinoContract) then throw("Permission denied") else
  if (indexAmount < 0) then throw("WIND amount can't be negative") else
  if (indexAmount > 0) then {
    strict stake = windContract.invoke("unstakeIndex", [indexAmount], [])
    if (i.caller == neutrinoContract) then {
      ([ScriptTransfer(neutrinoContract, indexAmount, windAssetId)], 0)
    } else {
      ([], 0)
    }
  } else { # indexAmount == 0, do nothing
    ([], 0)
  }
}

# These calls probably better to do manually:
# generateIndex(true) with 10 payments attached (convert 10 pool assets to WIND)
# generateIndexAndStake with 10 payments attached (convert 10 pool assets to WIND and stake)
# generateIndexWithOneTokenAndStake with payment in WAVES (convert WAVES to WIND and stake)