{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let revisionNum = ""

#-------------------Constants---------------------------
let PRICELET         = 1_000_000    # 10^6
let MULTSCALE        = 8
let EULERNUMBER      = 271828182      # 10Ë†8
let scale6           = 1_000_000
let scale6BigInt     = 1_000_000.toBigInt()
let scale8           = 1_0000_0000
let scale8BigInt     = 1_0000_0000.toBigInt()
let scale12          = 1_000_000_000_000
let scale18          = 1_000_000_000_000_000_000.toBigInt()
let SEP              = "__"

#-------this keys---------
func keyNeutrinoAddress()  = "%s%s__config__neutrinoAddress"
#-------neutrino keys------
func keyNeutrinoAssetId() = "neutrino_asset_id"
func keyLiquidationContractAddress() = "liquidation_contract"
func keyRPDContract() = "rpd_contract"
func keyAuctionContract() = "auction_contract"
func keyContolContract() = "control_contract"
func keyBondAssetId() = "bond_asset_id"
func keyBalanceLocked() = "balance_lock_"
func keyWavesLockedBalance() = keyBalanceLocked() + "waves"
func keyNeutrinoLockedBalance() = keyBalanceLocked() + "neutrino"
func keyMinWavesSwapAmount() = "min_waves_swap_amount"
func keyMinNeutrinoSwapAmount() = "min_neutrino_swap_amount"
func keyWavesOutFeePart() = "wavesOut_swap_feePart"
func keyNeutrinoOutFeePart() = "neutrinoOut_swap_feePart"
func keyNsbtLockContract() = "%s__nsbtLockContract"
func keyMathContract() = "%s__mathContract"

func keyBalanceWavesLockInterval() = "balance_waves_lock_interval"
func keyBalanceNeutrinoLockInterval() = "balance_neutrino_lock_interval"

#------control keys-------
func keyPrice() = "price"

#-------- nsbt staking keys-----------
func keyLockParamStartBlock(userAddress: String) = ["%s%s%s", "paramByUser", userAddress, "start"].makeString(SEP)
func keyHalfLife() = "%s__halfLife"
func keyMinLockAmount() = "%s__minLockAmount"

#------- auction keys------
func keyMinWavesForNsbtBuy() = "min_waves_nsbt_buy"
func keyMinNsbtSell() = "min_nsbt_sell"

#-------------------Base functions----------------------
func getStringOrFail(address: Address, key: String) = address.getString(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getIntOrFail(address: Address, key: String) = address.getInteger(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getBoolOrFail(address: Address, key: String) = address.getBoolean(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func convertNeutrinoToWaves(amount: Int, price: Int) = fraction(fraction(amount, PRICELET, price),scale8, scale6)
func convertWavesToNeutrino(amount: Int, price: Int) = fraction(fraction(amount, price, PRICELET), scale6, scale8)

func asAnyList(val: Any) = {
  match val {
    case valAnyList: List[Any] => valAnyList
    case _ => throw("fail to cast into List[Any]")
  }
}

func asInt(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("fail to cast into Int")
  }
}

func asString(val: Any) = {
  match val {
    case valStr: String => valStr
    case _ => throw("fail to cast into String")
  }
}

func asTuple2Ints(val: Any) = {
  match val {
    case v: (Int, Int) => v
    case _ => throw("fail to cast into Tuple2 ints")
  }
}

func asSwapParamsSTRUCT(val: Any) = {
  match val {
    case struct: (Int,Int,Int,Int,Int) => struct
    case _ => throw("fail to cast into Int")
  }
}

func toTimestamp(start: Int) = {
  match blockInfoByHeight(start) {
    case block: BlockInfo => block.timestamp
    case _ => -1
  }
}

func toX18(origVal: Int, origScaleMult: Int)          = fraction(origVal.toBigInt(), scale18, origScaleMult.toBigInt())
func fromX18(val: BigInt, resultScaleMult: Int)       = fraction(val, resultScaleMult.toBigInt(), scale18).toInt()

#-------------------GLOBAL VARIABLES-------------------------
let neutrinoContract = addressFromStringValue(this.getStringOrFail(keyNeutrinoAddress()))
let controlContract  = addressFromStringValue(neutrinoContract.getStringOrFail(keyContolContract()))
let auctionContract = addressFromStringValue(neutrinoContract.getStringOrFail(keyAuctionContract()))
let liquidationContract = neutrinoContract.getStringOrFail(keyLiquidationContractAddress())
let rpdContract = neutrinoContract.getStringOrFail(keyRPDContract())
let mathContract = addressFromStringValue(this.getStringOrFail(keyMathContract()))
let nsbtStakingContract = addressFromStringValue(this.getStringOrFail(keyNsbtLockContract()))

let neutrinoAssetIdString = neutrinoContract.getStringOrFail(keyNeutrinoAssetId())
let neutrinoAssetId = fromBase58String(neutrinoAssetIdString)
let nsbtAssetIdStr = neutrinoContract.getStringValue(keyBondAssetId())
let nsbtAssetId = nsbtAssetIdStr.fromBase58String()

func minWavesForNsbtBuy() = {
  auctionContract.invoke("minWavesAmountNsbtBuySYSREADONLY", [], []).asInt()
}

func minNsbtForSell() = {
  auctionContract.invoke("minNsbtAmountForSellSYSREADONLY", [], []).asInt()
}

func privateNsbtPriceREST() = {
  let prices = mathContract.invoke("calcContractNsbtPriceSYSREADONLY",[0],[]).asAnyList()

  let nsbt2usdnPrice         = prices[0].asInt()
  let nsbt2wavesPrice        = prices[1].asInt()

 (
    IntegerEntry("nsbt2usdnPrice",  nsbt2usdnPrice),
    IntegerEntry("nsbt2wavesPrice", nsbt2wavesPrice)
  )
}

@Callable(i)
# swapAmountAParam is scale8
func constructor(neutrinoAddress: String, nsbtLockAddress: String, mathAddress: String) = {
  if (i.caller != this) then throw("not authorized") else
  [
      StringEntry(keyNeutrinoAddress(), neutrinoAddress),
      StringEntry(keyNsbtLockContract(), nsbtLockAddress),
      StringEntry(keyMathContract(), mathAddress)
  ]
}

@Callable(i)
func neutrinoStatsREADONLY() = {
  let neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsREADONLY",[],[]).asAnyList()

  let prices = mathContract.invoke("calcContractNsbtPriceSYSREADONLY",[0],[]).asAnyList()

  let currentPrice           = neutrinoMetrics[0].asInt()
  let neutrinoLockedBalance  = neutrinoMetrics[1].asInt()
  let wavesLockedBalance     = neutrinoMetrics[2].asInt()
  let reservesInWaves        = neutrinoMetrics[3].asInt()
  let reservesInUsdn         = neutrinoMetrics[4].asInt()
  let neutrinoSupply         = neutrinoMetrics[5].asInt()
  let surplus                = neutrinoMetrics[6].asInt()
  let surplusPercent         = neutrinoMetrics[7].asInt()
  let BR                     = neutrinoMetrics[8].asInt()
  let nsbtSupply             = neutrinoMetrics[9].asInt()
  let maxNsbtSupply          = neutrinoMetrics[10].asInt()
  let nsbt2usdnPrice         = prices[0].asInt()
  let nsbt2wavesPrice        = prices[1].asInt()
  let minWaves4NsbtBuy       = minWavesForNsbtBuy()
  let minNsbtsell            = minNsbtForSell()
  let minNsbtLockAmt         = nsbtStakingContract.getIntOrFail(keyMinLockAmount())

  ([], makeString([
          "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
          currentPrice.toString(),          # 1
          neutrinoLockedBalance.toString(), # 2
          wavesLockedBalance.toString(),    # 3
          reservesInWaves.toString(),       # 4
          reservesInUsdn.toString(),        # 5
          neutrinoSupply.toString(),        # 6
          surplus.toString(),               # 7
          surplusPercent.toString(),        # 8
          BR.toString(),                    # 9
          nsbtSupply.toString(),            # 10
          maxNsbtSupply.toString(),         # 11
          nsbt2usdnPrice.toString(),        # 12
          nsbt2wavesPrice.toString(),       # 13
          minWaves4NsbtBuy.toString(),      # 14
          minNsbtsell.toString(),           # 15
          minNsbtLockAmt.toString()         # 16
          ], SEP))
}

@Callable(i)
func swapInfoREADONLY(userAddressStrOpt: String) = {
  let currentPrice           = controlContract.getIntegerValue(keyPrice())
  let minWavesSwapAmt        = neutrinoContract.getIntegerValue(keyMinWavesSwapAmount())
  let minUsdnSwapAmt         = neutrinoContract.getIntegerValue(keyMinNeutrinoSwapAmount())
  let waves2UsdnFee          = neutrinoContract.getIntegerValue(keyWavesOutFeePart())
  let usdn2WavesFee          = neutrinoContract.getIntegerValue(keyNeutrinoOutFeePart())
  let usdnSwapDelayDuration  = neutrinoContract.getIntegerValue(keyBalanceNeutrinoLockInterval())
  let wavesSwapDelayDuration = neutrinoContract.getIntegerValue(keyBalanceWavesLockInterval())

  let (swapLimitMaxUsdn, swapLimitSpentUsdn, blcks2LmtReset) = neutrinoContract.invoke("swapParamsByUserSYSREADONLY", [userAddressStrOpt, 0], []).asSwapParamsSTRUCT()
  let swapLimitMaxWaves = convertNeutrinoToWaves(swapLimitMaxUsdn, currentPrice)

  ([],
    makeString([
          "%d%d%d%d%d%d%d%d%d%d%d",         # 0
          currentPrice.toString(),          # 1
          minWavesSwapAmt.toString(),       # 2
          minUsdnSwapAmt.toString(),        # 3
          waves2UsdnFee.toString(),         # 4
          usdn2WavesFee.toString(),         # 5
          usdnSwapDelayDuration.toString(), # 6  usdn swap delay duration
          wavesSwapDelayDuration.toString(),# 7  waves swap delay duration
          blcks2LmtReset.toString(),        # 8
          swapLimitMaxWaves.toString(),     # 9  max allowed swap limit based on gnsbt balance
          swapLimitMaxUsdn.toString(),      # 10 max allowed swap limit based on gnsbt balance
          swapLimitSpentUsdn.toString()     # 11
          ], SEP))
}

@Callable(i)
func gnsbtInfoREADONLY(userAddressStrOpt: String, nsbtAmtDiff: Int) = {
  let currentPrice = controlContract.getIntegerValue(keyPrice())

  let (limitMaxUsdn, limitSpent, blcks2LmtReset, gnsbtAmt, gnsbtAmtTotal)
      = neutrinoContract.invoke("swapParamsByUserSYSREADONLY", [userAddressStrOpt, 0], []).asSwapParamsSTRUCT()

  let (limitMaxUsdnNEW, limitSpentNEW, blcks2LmtResetNEW, gnsbtAmtNEW, gnsbtAmtTotalNEW)
      = neutrinoContract.invoke("swapParamsByUserSYSREADONLY", [userAddressStrOpt, nsbtAmtDiff], []).asSwapParamsSTRUCT()

  let limitMaxWaves = convertNeutrinoToWaves(limitMaxUsdn, currentPrice)
  let limitMaxWavesNEW = convertNeutrinoToWaves(limitMaxUsdnNEW, currentPrice)

  let gnsbtShare = if (gnsbtAmtTotal != 0) then fraction(gnsbtAmt * 100, scale12, gnsbtAmtTotal) else 0
  let gnsbtShareNEW = if (gnsbtAmtTotalNEW != 0) then fraction(gnsbtAmtNEW * 100, scale12, gnsbtAmtTotalNEW) else 0

  let rewardInfo = nsbtStakingContract.invoke("unclaimedRewardsREADONLY", [userAddressStrOpt], []).asString()

  let nsbtAmt = gnsbtAmt
  let nsbtAmtNew = gnsbtAmtNEW
  let nsbtAmtStakedTotal = gnsbtAmtTotal
  let nsbtAmtStakedTotalNew = gnsbtAmtTotalNEW

  let nsbtData = nsbtStakingContract.invoke("nsbtStakingSYSREADONLY", [userAddressStrOpt], []).asAnyList()
  let startHeight = nsbtData[2].asInt()
  let startTimestamp = toTimestamp(startHeight)
  let halfLife = nsbtStakingContract.getIntOrFail(keyHalfLife());
  let startHeightNew = mathContract.invoke("mergeStakesREADONLY", [gnsbtAmt, startHeight, gnsbtAmtNEW, height, halfLife], []).asInt()
  let startTimestampNew = toTimestamp(startHeightNew)

  ([], makeString([
          "%d%d%d%d%d%d%d%d%s%d%d%d%d%d%d%d%d", # 0
          gnsbtAmt.toString(),              # 1
          gnsbtAmtNEW.toString(),           # 2
          gnsbtShare.toString(),            # 3
          gnsbtShareNEW.toString(),         # 4
          limitMaxUsdn.toString(),          # 5
          limitMaxWaves.toString(),         # 6
          limitMaxUsdnNEW.toString(),       # 7
          limitMaxWavesNEW.toString(),      # 8
          rewardInfo,                       # 9
          nsbtAmt.toString(),               # 10
          nsbtAmtNew.toString(),            # 11
          nsbtAmtStakedTotal.toString(),    # 12
          nsbtAmtStakedTotalNew.toString(), # 13
          startHeight.toString(),           # 14
          startTimestamp.toString(),        # 15
          startHeightNew.toString(),        # 16
          startTimestampNew.toString()      # 17
          ], SEP))
}

@Callable(i)
func buyNsbtREADONLY(wavesPay: Int) = {
  let minWavesAmountNsbtBuy = minWavesForNsbtBuy()
  if (wavesPay < minWavesAmountNsbtBuy) then throw("min " + minWavesAmountNsbtBuy.toString() + " waves expected") else

  strict curveResult = mathContract.invoke("curveFunctionREADONLY", [wavesPay], []).asAnyList()

  let nsbtAmount = curveResult[0].asInt()

  if (nsbtAmount <= 0) then throw("nsbtAmount <= 0") else

  ([], makeString(["%d", nsbtAmount.toString()], SEP))
}

# for evaluating merged stake height and amount
@Callable(i)
func mergedStakeREADONLY(amount1: Int, height1: Int, amount2: Int, height2: Int) = {
  let halfLife = nsbtStakingContract.getIntOrFail(keyHalfLife());
  strict h = mathContract.invoke("mergeStakesREADONLY", [amount1, height1, amount2, height2, halfLife], []).asInt()
  ([], makeString([
    "%d%d",
    (amount1 + amount2).toString(),
    h.toString()
    ], SEP))
}

@Callable(i)
func unstakeComissionAmountByHeightREADONLY(amount: Int, startHeight: Int) = {
  let halfLife = nsbtStakingContract.getIntOrFail(keyHalfLife());
  strict a = mathContract.invoke("getUnstakeComissionAmountREADONLY", [amount, startHeight, halfLife], []).asInt()
  ([], makeString(["%d", a.toString()], SEP))
}

@Callable(i)
func unstakeComissionAmountByUserREADONLY(amount: Int, userAddress: String) = {
  let halfLife = nsbtStakingContract.getIntOrFail(keyHalfLife());
  let startHeight = nsbtStakingContract.getInteger(keyLockParamStartBlock(userAddress)).valueOrElse(height)
  strict a = mathContract.invoke("getUnstakeComissionAmountREADONLY", [amount, startHeight, halfLife], []).asInt()
  ([], makeString(["%d", a.toString()], SEP))
}

@Callable(i)
func neutrinoStateREST() = {

  let neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsREADONLY",[],[]).asAnyList()

  let currentPrice           = neutrinoMetrics[0].asInt()
  let neutrinoLockedBalance  = neutrinoMetrics[1].asInt()
  let wavesLockedBalance     = neutrinoMetrics[2].asInt()
  let reservesInWaves        = neutrinoMetrics[3].asInt()
  let reservesInUsdn         = neutrinoMetrics[4].asInt()
  let neutrinoSupply         = neutrinoMetrics[5].asInt()
  let surplus                = neutrinoMetrics[6].asInt()
  let surplusPercent         = neutrinoMetrics[7].asInt()
  let BR                     = neutrinoMetrics[8].asInt()
  let nsbtSupply             = neutrinoMetrics[9].asInt()

  throw(
    makeString([
          "resultNeutrinoStateREST",        # 0
          currentPrice.toString(),          # 1
          neutrinoLockedBalance.toString(), # 2
          wavesLockedBalance.toString(),    # 3
          reservesInWaves.toString(),       # 4
          reservesInUsdn.toString(),        # 5
          neutrinoSupply.toString(),        # 6
          surplus.toString(),               # 7
          surplusPercent.toString(),        # 8
          BR.toString(),                    # 9
          nsbtSupply.toString()             # 10
          ],
    "__"))
}

@Callable(i)
func nsbtPriceREST() = {
  let prices = mathContract.invoke("calcContractNsbtPriceSYSREADONLY",[0],[]).asAnyList()

  let nsbt2usdnPrice         = prices[0].asInt()
  let nsbt2wavesPrice        = prices[1].asInt()

  let restData = makeString([
        "startNsbtPriceREST",       #0
        nsbt2usdnPrice.toString(),  #1
        nsbt2wavesPrice.toString(), #2
        "endNsbtPriceREST"          #3
        ],
    "__")

  throw(restData)
}

