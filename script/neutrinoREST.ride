{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#-------------------Constants---------------------------
let WAVELET          = 100_000_000
let PAULI            = 1_000_000
let PRICELET         = 1_000_000    # 10^6
let MULT             = 100_000_000  # 10^8
let MULTSCALE        = 8
let SEP              = "__"
let dora2NsbtSymbol  = "NSBT-USDT"

#-------this keys---------
func keyNeutrinoAddress()  = "%s%s__config__neutrinoAddress"
func keyDoraAddress()      = "%s%s__config__doraAddress"
#-------neutrino keys------
func keyNeutrinoAssetId() = "neutrino_asset_id"
func keyLiquidationContractAddress() = "liquidation_contract"
func keyRPDContract() = "rpd_contract"
func keyAuctionContract() = "auction_contract"
func keyContolContract() = "control_contract"
func keyBondAssetId() = "bond_asset_id"
func keyBalanceLocked() = "balance_lock_"
func keyWavesLockedBalance() = keyBalanceLocked() + "waves"
func keyNeutrinoLockedBalance() = keyBalanceLocked() + "neutrino"
func keyDora2LastHeightLimit() = "%s__dora2LastHeightLimit"
func keyMinWavesSwapAmount() = "min_waves_swap_amount"
func keyMinNeutrinoSwapAmount() = "min_neutrino_swap_amount"
func keyWavesOutFeePart() = "wavesOut_swap_feePart"
func keyNeutrinoOutFeePart() = "neutrinoOut_swap_feePart"
func keyNsbtLockContract() = "%s__nsbtLockContract"
func keyMathContract() = "%s__mathContract"
func keyQuickSwapLimitDuration() = "%s__quickSwapLimitDuration"
func keyUserLastQuickSwapHeight(userAddress: String) = ["%s%s", "userLastQuickSwapHeight", userAddress].makeString(SEP)
func keyQuickSwapUserSpentInPeriod(userAddress: String) = ["%s%s", "quickSwapUserSpentInPeriod", userAddress].makeString(SEP)

#------control keys-------
func keyPrice() = "price"

#-------------------Base functions----------------------
func getStringOrFail(address: Address, key: String) = address.getString(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getIntOrFail(address: Address, key: String) = address.getInteger(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getBoolOrFail(address: Address, key: String) = address.getBoolean(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func convertNeutrinoToWaves(amount: Int, price: Int) = fraction(fraction(amount, PRICELET, price),WAVELET, PAULI)
func convertWavesToNeutrino(amount: Int, price: Int) = fraction(fraction(amount, price, PRICELET), PAULI, WAVELET)
func asAnyList(val: Any) = {
  match val {
    case valAnyLyst: List[Any] => valAnyLyst
    case _ => throw("fail to cast into List[Any]")
  }
}
func asInt(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("fail to cast into Int")
  }
}

func asString(val: Any) = {
  match val {
    case valStr: String => valStr
    case _ => throw("fail to cast into String")
  }
}

# DORA2 Price Oracle
func keyDora2Price(symbol: String) = ["%s%s", "price", symbol].makeString(SEP)
func keyDora2LastHeight(symbol: String) = ["%s%s", "lastHeight", symbol].makeString(SEP)

#-------------------GLOBAL VARIABLES-------------------------
let neutrinoContract = addressFromStringValue(this.getStringOrFail(keyNeutrinoAddress()))
let controlContract  = addressFromStringValue(neutrinoContract.getStringOrFail(keyContolContract()))
let auctionContract = addressFromStringValue(neutrinoContract.getStringOrFail(keyAuctionContract()))
let liquidationContract = neutrinoContract.getStringOrFail(keyLiquidationContractAddress())
let rpdContract = neutrinoContract.getStringOrFail(keyRPDContract())
let mathContract = addressFromStringValue(this.getStringOrFail(keyMathContract()))

let neutrinoAssetIdString = neutrinoContract.getStringOrFail(keyNeutrinoAssetId())
let neutrinoAssetId = fromBase58String(neutrinoAssetIdString)
let nsbtAssetIdStr = neutrinoContract.getStringValue(keyBondAssetId())
let nsbtAssetId = nsbtAssetIdStr.fromBase58String()

#-------------------Global vars deficit, locked & supply -------------------------

@Callable(i)
func constructor(neutrinoAddress: String, doraAddress: String, nsbtLockAddress: String, mathAddress: String) = {
  if (i.caller != this) then throw("not authorized") else
  [
      StringEntry(keyNeutrinoAddress(), neutrinoAddress),
      StringEntry(keyDoraAddress(), doraAddress),
      StringEntry(keyNsbtLockContract(), nsbtLockAddress),
      StringEntry(keyMathContract(), mathAddress)
  ]
}

@Callable(i)
func neutrinoStatsREADONLY() = {
  strict neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsMATH",[],[]).asAnyList()
  strict prices = mathContract.invoke("calcContractNsbtPriceMATH()",[],[]).asAnyList()
  
  let currentPrice           = neutrinoMetrics[1].asInt()
  let neutrinoLockedBalance  = neutrinoMetrics[2].asInt()
  let wavesLockedBalance     = neutrinoMetrics[3].asInt()
  let reservesInWaves        = neutrinoMetrics[4].asInt()
  let reservesInUsdn         = neutrinoMetrics[5].asInt()
  let neutrinoSupply         = neutrinoMetrics[6].asInt()
  let surplus                = neutrinoMetrics[7].asInt()
  let surplusPercent         = neutrinoMetrics[8].asInt()
  let BR                     = neutrinoMetrics[9].asInt()
  let nsbtSupply             = neutrinoMetrics[10].asInt()
  let maxNsbtSupply          = neutrinoMetrics[11].asInt()
  let nsbt2usdnPrice         = prices[1].asInt()
  let nsbt2wavesPrice        = prices[2].asInt()
  
  ([], makeString([
          "%d%d%d%d%d%d%d%d%d%d%d%d",       # 0
          currentPrice.toString(),          # 1
          neutrinoLockedBalance.toString(), # 2
          wavesLockedBalance.toString(),    # 3
          reservesInWaves.toString(),       # 4
          reservesInUsdn.toString(),        # 5
          neutrinoSupply.toString(),        # 6
          surplus.toString(),               # 7
          surplusPercent.toString(),        # 8
          BR.toString(),                    # 9
          nsbtSupply.toString(),            # 10
          maxNsbtSupply.toString(),         # 11
          nsbt2usdnPrice.toString(),        # 12
          nsbt2wavesPrice.toString()        # 13
          ], SEP))
}

@Callable(i)
func dora2NSBTInfoREADONLY() = {
  let doraContract = this.getStringValue(keyDoraAddress()).addressFromStringValue()
  let (nsbtPrice, nsbtPriceLastHeight) = (
    doraContract.getInteger(keyDora2Price(dora2NsbtSymbol)).valueOrErrorMessage("DORA NSBT price is undefined"), # price
    doraContract.getInteger(keyDora2LastHeight(dora2NsbtSymbol)).valueOrElse(0) # last height
  )
  ([], (nsbtPrice, nsbtPriceLastHeight))
}

@Callable(i)
func calcTotalQuickSwapLimitREADONLY(gNsbtAmount: Int) = {
  let dora2nsbtInfo = this.invoke("dora2NSBTInfoREADONLY", [], []).asAnyList()
  let nsbtPrice = dora2nsbtInfo[1].asInt() 
  let nsbtPriceLastHeight = dora2nsbtInfo[2].asInt() 
  strict check = if (height - nsbtPriceLastHeight > neutrinoContract.getIntegerValue(keyDora2LastHeightLimit())) then throw("NSBT price is outdated") else true
  ([],  makeString([
          "%d",  
          fraction(gNsbtAmount, nsbtPrice, WAVELET).toString()], SEP))
}

@Callable(i)
func swapInfoREADONLY(userAddressStr: String) = {
  let currentPrice           = controlContract.getIntegerValue(keyPrice())
  let minWavesSwapAmt        = neutrinoContract.getIntegerValue(keyMinWavesSwapAmount())
  let minUsdnSwapAmt         = neutrinoContract.getIntegerValue(keyMinNeutrinoSwapAmount())
  let waves2UsdnFee          = neutrinoContract.getIntegerValue(keyWavesOutFeePart())
  let usdn2WavesFee          = neutrinoContract.getIntegerValue(keyNeutrinoOutFeePart())
  let usdnSwapDelayDuration  = neutrinoContract.getIntegerValue(keyNeutrinoOutFeePart())
  let wavesSwapDelayDuration = neutrinoContract.getIntegerValue(keyNeutrinoOutFeePart())
  let (quickSwapUserSpent, 
      currentUsdnLimit,
      currentWavesLimit,
      blocks2LimitReset, 
      maxUsdnLimit, 
      maxWavesLimit) = if(userAddressStr == "") then (0,0,0,0,0,0) else

      strict userGNsbtAmount = this.getStringValue(keyNsbtLockContract()).addressFromStringValue()
        .invoke("nsbtStakingInfoWrapperREADONLY", [userAddressStr], []).asInt()
        
      strict usdnLmtMax = this.invoke("calcTotalQuickSwapLimitREADONLY", [userGNsbtAmount], []).asString().split(SEP)[1].asInt()
      let quickSwapResetBlocks = neutrinoContract.getIntegerValue(keyQuickSwapLimitDuration())
      let lastQuickSwapBlock = neutrinoContract.getInteger(keyUserLastQuickSwapHeight(userAddressStr)).valueOrElse(0)
      let isNewQuickSwapPeriod = height - lastQuickSwapBlock > quickSwapResetBlocks
      let quickSwapUserSpent = if (isNewQuickSwapPeriod) then 0 else neutrinoContract.getInteger(keyQuickSwapUserSpentInPeriod(userAddressStr)).valueOrElse(0)
      
      let usdnLmtNow = usdnLmtMax - quickSwapUserSpent
      let wavesLmtNow = convertNeutrinoToWaves(usdnLmtNow, currentPrice)
      let blcks2LmtReset = if (isNewQuickSwapPeriod) then 0 else quickSwapResetBlocks - (height - lastQuickSwapBlock)
      let wavesLmtMax = convertNeutrinoToWaves(usdnLmtMax, currentPrice)
      (quickSwapUserSpent, usdnLmtNow, wavesLmtNow, blcks2LmtReset, usdnLmtMax, wavesLmtMax)

  ([], 
    makeString([
          "%d%d%d%d%d%d%d%d%d%d",      
          currentPrice.toString(), 
          currentWavesLimit.toString(),
          currentUsdnLimit.toString(),
          blocks2LimitReset.toString(),
          maxWavesLimit.toString(), # max allowed swap limit based on gnsbt balance
          maxUsdnLimit.toString(),
          quickSwapUserSpent.toString(),
          minWavesSwapAmt.toString(),
          minUsdnSwapAmt.toString(),
          waves2UsdnFee.toString(),
          usdn2WavesFee.toString(),
          "1", # usdn swap delay duration
          "1"  # waves swap delay duration
          # My gNSBT share
          # Already Claimed in USDN (calculate WAVES part to usdn by current rate)
          # Already Claimed USDN (calculate WAVES part to usdn by current rate)
          # Already Claimed WAVES (calculate WAVES part to usdn by current rate)
          # UNClaimed in USDN (calculate WAVES part to usdn by current rate)
          # UNClaimed USDN (calculate WAVES part to usdn by current rate)
          # UNClaimed WAVES (calculate WAVES part to usdn by current rate)
          
          ], SEP))
}

