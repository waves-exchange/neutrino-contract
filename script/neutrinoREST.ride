{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#-------------------Constants---------------------------
let PRICELET         = 1_000_000    # 10^6
let MULTSCALE        = 8
let EULERNUMBER      = 271828182      # 10Ë†8
let scale6           = 1_000_000
let scale6BigInt     = 1_000_000.toBigInt()
let scale8           = 1_0000_0000
let scale8BigInt     = 1_0000_0000.toBigInt()
let scale18          = 1_000_000_000_000_000_000.toBigInt()
let SEP              = "__"

#-------this keys---------
func keyNeutrinoAddress()  = "%s%s__config__neutrinoAddress"
#-------neutrino keys------
func keyNeutrinoAssetId() = "neutrino_asset_id"
func keyLiquidationContractAddress() = "liquidation_contract"
func keyRPDContract() = "rpd_contract"
func keyAuctionContract() = "auction_contract"
func keyContolContract() = "control_contract"
func keyBondAssetId() = "bond_asset_id"
func keyBalanceLocked() = "balance_lock_"
func keyWavesLockedBalance() = keyBalanceLocked() + "waves"
func keyNeutrinoLockedBalance() = keyBalanceLocked() + "neutrino"
func keyMinWavesSwapAmount() = "min_waves_swap_amount"
func keyMinNeutrinoSwapAmount() = "min_neutrino_swap_amount"
func keyWavesOutFeePart() = "wavesOut_swap_feePart"
func keyNeutrinoOutFeePart() = "neutrinoOut_swap_feePart"
func keyNsbtLockContract() = "%s__nsbtLockContract"
func keyMathContract() = "%s__mathContract"
func keyQuickSwapLimitDuration() = "%s__quickSwapLimitDuration"
func keyUserLastQuickSwapHeight(userAddress: String) = ["%s%s", "userLastQuickSwapHeight", userAddress].makeString(SEP)
func keyQuickSwapUserSpentInPeriod(userAddress: String) = ["%s%s", "quickSwapUserSpentInPeriod", userAddress].makeString(SEP)
func keyBalanceWavesLockInterval() = "balance_waves_lock_interval"
func keyBalanceNeutrinoLockInterval() = "balance_neutrino_lock_interval"
func keySwapsTimeframe() = "swaps_timeframe"

#------control keys-------
func keyPrice() = "price"

#-------- nsbt staking keys-----------
func keyLockParamUserAmount(userAddress: String) = ["%s%s%s", "paramByUser", userAddress, "amount"].makeString(SEP)
func keyLockParamStartBlock(userAddress: String) = ["%s%s%s", "paramByUser", userAddress, "start"].makeString(SEP)
func keyMinLockAmount() = "%s__minLockAmount"

#------- auction keys------
func keyMinWavesForNsbtBuy() = "min_waves_nsbt_buy"
func keyMinNsbtSell() = "min_nsbt_sell"

#-------------------Base functions----------------------
func getStringOrFail(address: Address, key: String) = address.getString(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getIntOrFail(address: Address, key: String) = address.getInteger(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getBoolOrFail(address: Address, key: String) = address.getBoolean(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func convertNeutrinoToWaves(amount: Int, price: Int) = fraction(fraction(amount, PRICELET, price),scale8, scale6)
func convertWavesToNeutrino(amount: Int, price: Int) = fraction(fraction(amount, price, PRICELET), scale6, scale8)
func asAnyList(val: Any) = {
  match val {
    case valAnyList: List[Any] => valAnyList
    case _ => throw("fail to cast into List[Any]")
  }
}

func asInt(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("fail to cast into Int")
  }
}

func asString(val: Any) = {
  match val {
    case valStr: String => valStr
    case _ => throw("fail to cast into String")
  }
}

func toX18(origVal: Int, origScaleMult: Int)          = fraction(origVal.toBigInt(), scale18, origScaleMult.toBigInt())
func fromX18(val: BigInt, resultScaleMult: Int)       = fraction(val, resultScaleMult.toBigInt(), scale18).toInt()


#-------------------GLOBAL VARIABLES-------------------------
let neutrinoContract = addressFromStringValue(this.getStringOrFail(keyNeutrinoAddress()))
let controlContract  = addressFromStringValue(neutrinoContract.getStringOrFail(keyContolContract()))
let auctionContract = addressFromStringValue(neutrinoContract.getStringOrFail(keyAuctionContract()))
let liquidationContract = neutrinoContract.getStringOrFail(keyLiquidationContractAddress())
let rpdContract = neutrinoContract.getStringOrFail(keyRPDContract())
let mathContract = addressFromStringValue(this.getStringOrFail(keyMathContract()))
let nsbtStakingContract = addressFromStringValue(this.getStringOrFail(keyNsbtLockContract()))

let neutrinoAssetIdString = neutrinoContract.getStringOrFail(keyNeutrinoAssetId())
let neutrinoAssetId = fromBase58String(neutrinoAssetIdString)
let nsbtAssetIdStr = neutrinoContract.getStringValue(keyBondAssetId())
let nsbtAssetId = nsbtAssetIdStr.fromBase58String()

#-------------------Global vars deficit, locked & supply -------------------------

@Callable(i)
# swapAmountAParam is scale8
func constructor(neutrinoAddress: String, nsbtLockAddress: String, mathAddress: String) = {
  if (i.caller != this) then throw("not authorized") else
  [
      StringEntry(keyNeutrinoAddress(), neutrinoAddress),
      StringEntry(keyNsbtLockContract(), nsbtLockAddress),
      StringEntry(keyMathContract(), mathAddress)
  ]
}

@Callable(i)
func neutrinoStatsREADONLY() = {
  strict neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsMATH",[],[]).asAnyList()
  
  strict prices = mathContract.invoke("calcContractNsbtPriceMATH",[],[]).asAnyList()
  
  let currentPrice           = neutrinoMetrics[0].asInt()
  let neutrinoLockedBalance  = neutrinoMetrics[1].asInt()
  let wavesLockedBalance     = neutrinoMetrics[2].asInt()
  let reservesInWaves        = neutrinoMetrics[3].asInt()
  let reservesInUsdn         = neutrinoMetrics[4].asInt()
  let neutrinoSupply         = neutrinoMetrics[5].asInt()
  let surplus                = neutrinoMetrics[6].asInt()
  let surplusPercent         = neutrinoMetrics[7].asInt()
  let BR                     = neutrinoMetrics[8].asInt()
  let nsbtSupply             = neutrinoMetrics[9].asInt()
  let maxNsbtSupply          = neutrinoMetrics[10].asInt()
  let nsbt2usdnPrice         = prices[0].asInt()
  let nsbt2wavesPrice        = prices[1].asInt()
  let minWaves4NsbtBuy       = auctionContract.getIntegerValue(keyMinWavesForNsbtBuy())
  let minNsbtsell            = auctionContract.getIntegerValue(keyMinNsbtSell())
  
  ([], makeString([
          "%d%d%d%d%d%d%d%d%d%d%d%d%d",     # 0
          currentPrice.toString(),          # 1
          neutrinoLockedBalance.toString(), # 2
          wavesLockedBalance.toString(),    # 3
          reservesInWaves.toString(),       # 4
          reservesInUsdn.toString(),        # 5
          neutrinoSupply.toString(),        # 6
          surplus.toString(),               # 7
          surplusPercent.toString(),        # 8
          BR.toString(),                    # 9
          nsbtSupply.toString(),            # 10
          maxNsbtSupply.toString(),         # 11
          nsbt2usdnPrice.toString(),        # 12
          nsbt2wavesPrice.toString(),       # 13
          minWaves4NsbtBuy.toString(),       # 14    
          minNsbtsell.toString()            # 15    
          ], SEP))
}

@Callable(i)
func swapInfoREADONLY(userAddressStr: String) = {
  let currentPrice           = controlContract.getIntegerValue(keyPrice())
  let minWavesSwapAmt        = neutrinoContract.getIntegerValue(keyMinWavesSwapAmount())
  let minUsdnSwapAmt         = neutrinoContract.getIntegerValue(keyMinNeutrinoSwapAmount())
  let waves2UsdnFee          = neutrinoContract.getIntegerValue(keyWavesOutFeePart())
  let usdn2WavesFee          = neutrinoContract.getIntegerValue(keyNeutrinoOutFeePart())
  let usdnSwapDelayDuration  = neutrinoContract.getIntegerValue(keyBalanceNeutrinoLockInterval())
  let wavesSwapDelayDuration = neutrinoContract.getIntegerValue(keyBalanceWavesLockInterval())

  let (quickSwapUserSpent, 
      blocks2LimitReset, 
      maxUsdnLimit, 
      maxWavesLimit) = if(userAddressStr == "") then (0,0,0,0) else
      
      let userGNsbtAmount = nsbtStakingContract.getInteger(keyLockParamUserAmount(userAddressStr)).valueOrElse(0)
      strict usdnLmtMax = mathContract.invoke("calcSwapLimitMATH", [userGNsbtAmount], []).asInt()
      let quickSwapResetBlocks = neutrinoContract.getInteger(keySwapsTimeframe()).valueOrElse(1440)
      let lastQuickSwapBlock = neutrinoContract.getInteger(keyUserLastQuickSwapHeight(userAddressStr)).valueOrElse(0)
      let isNewQuickSwapPeriod = height - lastQuickSwapBlock > quickSwapResetBlocks
      let quickSwapUserSpent = if (isNewQuickSwapPeriod) then 0 else neutrinoContract.getInteger(keyQuickSwapUserSpentInPeriod(userAddressStr)).valueOrElse(0)
      let blcks2LmtReset = if (isNewQuickSwapPeriod) then 0 else quickSwapResetBlocks - (height - lastQuickSwapBlock)
      let wavesLmtMax = convertNeutrinoToWaves(usdnLmtMax, currentPrice)
      (quickSwapUserSpent, blcks2LmtReset, usdnLmtMax, wavesLmtMax)

  ([], 
    makeString([
          "%d%d%d%d%d%d%d%d%d%d%d",      
          currentPrice.toString(), 
          minWavesSwapAmt.toString(),
          minUsdnSwapAmt.toString(),
          waves2UsdnFee.toString(),
          usdn2WavesFee.toString(),
          usdnSwapDelayDuration.toString(), # usdn swap delay duration
          wavesSwapDelayDuration.toString(),  # waves swap delay duration          
          blocks2LimitReset.toString(),
          maxWavesLimit.toString(), # max allowed swap limit based on gnsbt balance
          maxUsdnLimit.toString(),  # max allowed swap limit based on gnsbt balance
          quickSwapUserSpent.toString()
          ], SEP))
}

@Callable(i)
func gnsbtInfoREADONLY(userAddressStr: String) = {
  let gnsbtShare = 10000
  let claimedTotalInUsdn = 10000;
  let claimedUsdn = 10000
  let claimedWaves = 10000
  let unclaimedTotalInUsdn = 10000
  let unclaimedUsdn = 10000
  let unclaimedWaves = 10000

  ([], 
    makeString([
          "%d%d%d%d%d%d%d",  
          gnsbtShare.toString(),
          claimedTotalInUsdn.toString(),
          claimedUsdn.toString(),
          claimedWaves.toString(),
          unclaimedTotalInUsdn.toString(),
          unclaimedUsdn.toString(),
          unclaimedWaves.toString()        
          ], SEP))
}

@Callable(i)
func buyNsbtREADONLY(wavesPay: Int) = {
  let minWavesAmountNsbtBuy = auctionContract.getIntegerValue(keyMinWavesForNsbtBuy()) 
  if (wavesPay < minWavesAmountNsbtBuy) then throw("min " + minWavesAmountNsbtBuy.toString() + " waves expected") else

  strict neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsMATH", [], []).asAnyList()
  let currentPrice   = neutrinoMetrics[0].asInt()
  let reserve        = neutrinoMetrics[3].asInt()
  let neutrinoSupply = neutrinoMetrics[5].asInt()
  let nsbtSupply     = neutrinoMetrics[9].asInt()
  let nsbtSupplyMAX  = assetInfo(nsbtAssetId).value().quantity
  strict curveResult = mathContract.invoke("curveFunctionMATH", [reserve, neutrinoSupply, currentPrice, nsbtSupplyMAX, nsbtSupply, wavesPay], []).asAnyList()
  
  let nsbtAmount = curveResult[0].asInt()

  if (nsbtAmount <= 0) then throw("nsbtAmount <= 0") else
  if (nsbtAmount * 9223372 < wavesPay) then throw("Nsbt2Waves price exceeds MAX_INT: " + toString(wavesPay) + "/" + toString(nsbtAmount)) else

  ([], makeString(["%d", nsbtAmount.toString()], SEP))
}

# (Min staked amount for NSBT staking)
@Callable(i)
func minStakedAmountREADONLY() = {
  ([], makeString([
    "%d", 
    nsbtStakingContract.getIntOrFail(keyMinLockAmount()).toString()
    ], SEP))
}

# for evaluating merged stake height and amount
@Callable(i)
func mergedStakeREADONLY(amount1: Int, height1: Int, amount2: Int, height2: Int) = {
  strict h = mathContract.invoke("mergeStakesMATH", [amount1, height1, amount2, height2], []).asInt()
  ([], makeString([
    "%d%d", 
    (amount1 + amount2).toString(), 
    h.toString()
    ], SEP))
}

@Callable(i)
func unstakeComissionAmountREADONLY(amount: Int, startHeight: Int) = {
  strict a = mathContract.invoke("getUnstakeComissionAmountMATH", [amount, startHeight], []).asInt()
  ([], makeString(["%d", a.toString()], SEP))
}
