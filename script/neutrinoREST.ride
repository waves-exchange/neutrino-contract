{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#-------------------Constants---------------------------
let PRICELET         = 1_000_000    # 10^6
let MULTSCALE        = 8
let EULERNUMBER      = 271828182      # 10Ë†8
let scale6           = 1_000_000
let scale6BigInt     = 1_000_000.toBigInt()
let scale8           = 100_000_000
let scale8BigInt     = 100_000_000.toBigInt()
let scale18          = 1_000_000_000_000_000_000.toBigInt()
let SEP              = "__"
let dora2NsbtSymbol  = "NSBT-USDT"

#-------this keys---------
func keyNeutrinoAddress()  = "%s%s__config__neutrinoAddress"
func keyDoraAddress()      = "%s%s__config__doraAddress"
func keySwapAmountAParam() = "%s%s__config__swapAParam"
#-------neutrino keys------
func keyNeutrinoAssetId() = "neutrino_asset_id"
func keyLiquidationContractAddress() = "liquidation_contract"
func keyRPDContract() = "rpd_contract"
func keyAuctionContract() = "auction_contract"
func keyContolContract() = "control_contract"
func keyBondAssetId() = "bond_asset_id"
func keyBalanceLocked() = "balance_lock_"
func keyWavesLockedBalance() = keyBalanceLocked() + "waves"
func keyNeutrinoLockedBalance() = keyBalanceLocked() + "neutrino"
func keyDora2LastHeightLimit() = "%s__dora2LastHeightLimit"
func keyMinWavesSwapAmount() = "min_waves_swap_amount"
func keyMinNeutrinoSwapAmount() = "min_neutrino_swap_amount"
func keyWavesOutFeePart() = "wavesOut_swap_feePart"
func keyNeutrinoOutFeePart() = "neutrinoOut_swap_feePart"
func keyNsbtLockContract() = "%s__nsbtLockContract"
func keyMathContract() = "%s__mathContract"
func keyQuickSwapLimitDuration() = "%s__quickSwapLimitDuration"
func keyUserLastQuickSwapHeight(userAddress: String) = ["%s%s", "userLastQuickSwapHeight", userAddress].makeString(SEP)
func keyQuickSwapUserSpentInPeriod(userAddress: String) = ["%s%s", "quickSwapUserSpentInPeriod", userAddress].makeString(SEP)
func keyBalanceWavesLockInterval() = "balance_waves_lock_interval"
func keyBalanceNeutrinoLockInterval() = "balance_neutrino_lock_interval"

#------control keys-------
func keyPrice() = "price"

#-------- nsbt staking keys-----------
func keyLockParamUserAmount(userAddress: String) = ["%s%s%s", "paramByUser", userAddress, "amount"].makeString(SEP)
func keyLockParamStartBlock(userAddress: String) = ["%s%s%s", "paramByUser", userAddress, "start"].makeString(SEP)

#------- auction keys------
func keyMinWavesForNsbtBuy() = "min_waves_nsbt_buy"

#-------------------Base functions----------------------
func getStringOrFail(address: Address, key: String) = address.getString(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getIntOrFail(address: Address, key: String) = address.getInteger(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getBoolOrFail(address: Address, key: String) = address.getBoolean(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func convertNeutrinoToWaves(amount: Int, price: Int) = fraction(fraction(amount, PRICELET, price),scale8, scale6)
func convertWavesToNeutrino(amount: Int, price: Int) = fraction(fraction(amount, price, PRICELET), scale6, scale8)
func asAnyList(val: Any) = {
  match val {
    case valAnyLyst: List[Any] => valAnyLyst
    case _ => throw("fail to cast into List[Any]")
  }
}
func asInt(val: Any) = {
  match val {
    case valInt: Int => valInt
    case _ => throw("fail to cast into Int")
  }
}

func asString(val: Any) = {
  match val {
    case valStr: String => valStr
    case _ => throw("fail to cast into String")
  }
}

func toX18(origVal: Int, origScaleMult: Int)          = fraction(origVal.toBigInt(), scale18, origScaleMult.toBigInt())
func fromX18(val: BigInt, resultScaleMult: Int)       = fraction(val, resultScaleMult.toBigInt(), scale18).toInt()


# DORA2 Price Oracle
func keyDora2Price(symbol: String) = ["%s%s", "price", symbol].makeString(SEP)
func keyDora2LastHeight(symbol: String) = ["%s%s", "lastHeight", symbol].makeString(SEP)

#-------------------GLOBAL VARIABLES-------------------------
let neutrinoContract = addressFromStringValue(this.getStringOrFail(keyNeutrinoAddress()))
let controlContract  = addressFromStringValue(neutrinoContract.getStringOrFail(keyContolContract()))
let auctionContract = addressFromStringValue(neutrinoContract.getStringOrFail(keyAuctionContract()))
let liquidationContract = neutrinoContract.getStringOrFail(keyLiquidationContractAddress())
let rpdContract = neutrinoContract.getStringOrFail(keyRPDContract())
let mathContract = addressFromStringValue(this.getStringOrFail(keyMathContract()))
let nsbtStakingContract = addressFromStringValue(this.getStringOrFail(keyNsbtLockContract()))

let neutrinoAssetIdString = neutrinoContract.getStringOrFail(keyNeutrinoAssetId())
let neutrinoAssetId = fromBase58String(neutrinoAssetIdString)
let nsbtAssetIdStr = neutrinoContract.getStringValue(keyBondAssetId())
let nsbtAssetId = nsbtAssetIdStr.fromBase58String()

#-------------------Global vars deficit, locked & supply -------------------------

@Callable(i)
# swapAmountAParam is scale8
func constructor(neutrinoAddress: String, doraAddress: String, nsbtLockAddress: String, mathAddress: String, swapAmountAParam: Int) = {
  if (i.caller != this) then throw("not authorized") else
  [
      StringEntry(keyNeutrinoAddress(), neutrinoAddress),
      StringEntry(keyDoraAddress(), doraAddress),
      StringEntry(keyNsbtLockContract(), nsbtLockAddress),
      StringEntry(keyMathContract(), mathAddress),
      IntegerEntry(keySwapAmountAParam(), swapAmountAParam)
  ]
}

@Callable(i)
func neutrinoStatsREADONLY() = {
  strict neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsMATH",[],[]).asAnyList()
  strict prices = mathContract.invoke("calcContractNsbtPriceMATH()",[],[]).asAnyList()
  
  let currentPrice           = neutrinoMetrics[1].asInt()
  let neutrinoLockedBalance  = neutrinoMetrics[2].asInt()
  let wavesLockedBalance     = neutrinoMetrics[3].asInt()
  let reservesInWaves        = neutrinoMetrics[4].asInt()
  let reservesInUsdn         = neutrinoMetrics[5].asInt()
  let neutrinoSupply         = neutrinoMetrics[6].asInt()
  let surplus                = neutrinoMetrics[7].asInt()
  let surplusPercent         = neutrinoMetrics[8].asInt()
  let BR                     = neutrinoMetrics[9].asInt()
  let nsbtSupply             = neutrinoMetrics[10].asInt()
  let maxNsbtSupply          = neutrinoMetrics[11].asInt()
  let nsbt2usdnPrice         = prices[1].asInt()
  let nsbt2wavesPrice        = prices[2].asInt()
  let minWaves4NsbtBuy       = auctionContract.getIntegerValue(keyMinWavesForNsbtBuy())
  
  ([], makeString([
          "%d%d%d%d%d%d%d%d%d%d%d%d%d",     # 0
          currentPrice.toString(),          # 1
          neutrinoLockedBalance.toString(), # 2
          wavesLockedBalance.toString(),    # 3
          reservesInWaves.toString(),       # 4
          reservesInUsdn.toString(),        # 5
          neutrinoSupply.toString(),        # 6
          surplus.toString(),               # 7
          surplusPercent.toString(),        # 8
          BR.toString(),                    # 9
          nsbtSupply.toString(),            # 10
          maxNsbtSupply.toString(),         # 11
          nsbt2usdnPrice.toString(),        # 12
          nsbt2wavesPrice.toString(),       # 13
          minWaves4NsbtBuy.toString()       # 14        
          ], SEP))
}

@Callable(i)
func calcSwapLimitREADONLY(gNsbtAmount: Int) = {
  # limit = a * gNsbtAmount^e 
  let usdnSwapDelayDuration  = this.getIntegerValue(keySwapAmountAParam()).valueOrErrorMessage("Swap parameter A missed.")
  let gNsbtAmountBigInt = gNsbtAmount.toBigInt()
  let limitPowPart = pow(gNsbtAmountBigInt, 0, EULERNUMBER.toBigInt(), 8, 0, DOWN)
  let limit = fraction(usdnSwapDelayDuration.toBigInt(), limitPowPart, scale6BigInt)
  ([],  makeString([
          "%d",  
          limit.toString()], SEP))
}

@Callable(i)
func swapInfoREADONLY(userAddressStr: String) = {
  let currentPrice           = controlContract.getIntegerValue(keyPrice())
  let minWavesSwapAmt        = neutrinoContract.getIntegerValue(keyMinWavesSwapAmount())
  let minUsdnSwapAmt         = neutrinoContract.getIntegerValue(keyMinNeutrinoSwapAmount())
  let waves2UsdnFee          = neutrinoContract.getIntegerValue(keyWavesOutFeePart())
  let usdn2WavesFee          = neutrinoContract.getIntegerValue(keyNeutrinoOutFeePart())
  let usdnSwapDelayDuration  = neutrinoContract.getIntegerValue(keyBalanceNeutrinoLockInterval())
  let wavesSwapDelayDuration = neutrinoContract.getIntegerValue(keyBalanceWavesLockInterval())

  let (quickSwapUserSpent, 
      blocks2LimitReset, 
      maxUsdnLimit, 
      maxWavesLimit) = if(userAddressStr == "") then (0,0,0,0) else

      strict userGNsbtAmount = nsbtStakingContract.getInteger(keyLockParamUserAmount(userAddressStr)).valueOrElse(0)
        
      strict usdnLmtMax = this.invoke("calcSwapLimitREADONLY", [userGNsbtAmount], []).asString().split(SEP)[1].asInt()
      let quickSwapResetBlocks = neutrinoContract.getIntegerValue(keyQuickSwapLimitDuration())
      let lastQuickSwapBlock = neutrinoContract.getInteger(keyUserLastQuickSwapHeight(userAddressStr)).valueOrElse(0)
      let isNewQuickSwapPeriod = height - lastQuickSwapBlock > quickSwapResetBlocks
      let quickSwapUserSpent = if (isNewQuickSwapPeriod) then 0 else neutrinoContract.getInteger(keyQuickSwapUserSpentInPeriod(userAddressStr)).valueOrElse(0)
      
      let blcks2LmtReset = if (isNewQuickSwapPeriod) then 0 else quickSwapResetBlocks - (height - lastQuickSwapBlock)
      let wavesLmtMax = convertNeutrinoToWaves(usdnLmtMax, currentPrice)
      (quickSwapUserSpent, blcks2LmtReset, usdnLmtMax, wavesLmtMax)

  ([], 
    makeString([
          "%d%d%d%d%d%d%d%d%d%d%d",      
          currentPrice.toString(), 
          minWavesSwapAmt.toString(),
          minUsdnSwapAmt.toString(),
          waves2UsdnFee.toString(),
          usdn2WavesFee.toString(),
          usdnSwapDelayDuration.toString(), # usdn swap delay duration
          wavesSwapDelayDuration.toString(),  # waves swap delay duration          
          blocks2LimitReset.toString(),
          maxWavesLimit.toString(), # max allowed swap limit based on gnsbt balance
          maxUsdnLimit.toString(),  # max allowed swap limit based on gnsbt balance
          quickSwapUserSpent.toString()
          ], SEP))
}

@Callable(i)
func gnsbtInfoREADONLY(userAddressStr: String) = {
  let gnsbtShare = 10000
  let claimedTotalInUsdn = 10000;
  let claimedUsdn = 10000
  let claimedWaves = 10000
  let unclaimedTotalInUsdn = 10000
  let unclaimedUsdn = 10000
  let unclaimedWaves = 10000

  ([], 
    makeString([
          "%d%d%d%d%d%d%d",  
          gnsbtShare.toString(),
          claimedTotalInUsdn.toString(),
          claimedUsdn.toString(),
          claimedWaves.toString(),
          unclaimedTotalInUsdn.toString(),
          unclaimedUsdn.toString(),
          unclaimedWaves.toString()        
          ], SEP))
}


