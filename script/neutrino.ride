{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
#
# Main Smart Contract of Neutrino Protocol
# Implemented actions: Swap, Bond Liquidation, Leasing
#
let revisionNum = ""

#-------------------Base functions----------------------
func getStringOrFail(address: Address, key: String) = {
  address.getString(key).valueOrErrorMessage("Mandatory this." + key + " is not defined")
}

# workaround to reduce size
func lcalc(l: Lease) = {
  calculateLeaseId(l)
}

func getNumberByKey(key: String) = {
    getInteger(this, key).valueOrElse(0)
}
func getStringByKey(key: String) = {
    getString(this, key).valueOrElse("")
}
func getBoolByKey(key: String) = {
    getBoolean(this, key).valueOrElse(false)
}
func getNumberByAddressAndKey(address: String, key: String) = {
    getInteger(addressFromStringValue(address), key).valueOrElse(0)
}
func getStringByAddressAndKey(address: String, key: String) = {
     getString(addressFromStringValue(address), key).valueOrElse("")
}
func getBoolByAddressAndKey(address: String, key: String) = {
     getBoolean(addressFromStringValue(address), key).valueOrElse(false)
}
func asAnyList(v: Any) = {
  match v {
    case l: List[Any] => l
    case _ => throw("fail to cast into List[Any]")
  }
}
func asString(v: Any) = {
  match v {
    case s: String => s
    case _ => throw("fail to cast into String")
  }
}
func asInt(v: Any) = {
  match v {
    case i: Int => i
    case _ => throw("fail to cast into Int")
  }
}

func asPayment(v: Any) = {
  match v {
    case p: AttachedPayment => p
    case _ => throw("fail to cast into AttachedPayment")
  }
}

func asSwapParamsSTRUCT(v: Any) = {
  match v {
    case struct: (Int, Int, Int, Int, Int) => struct
    case _ => throw("fail to cast into Int")
  }
}

#-------------------Constants---------------------------
let SEP = "__"
let WAVELET = 100000000
let PAULI = 1000000
let PRICELET = 1000000 # 10^6
let DEFAULTSWAPFEE = 20000 # 0.02 * 1000000 or 2%

let IdxNetAmount = 0
let IdxFeeAmount = 1
let IdxGrossAmount = 2

#-------------------Constructor-------------------------
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let AuctionContractKey = "auction_contract"
let NsbtStakingContractKey = "nsbtStakingContract"
let LiquidationContractKey = "liquidation_contract"
let RPDContractKey = "rpd_contract"
let ContolContractKey = "control_contract"
let MathContractKey = "math_contract"
let BalanceWavesLockIntervalKey = "balance_waves_lock_interval"
let BalanceNeutrinoLockIntervalKey = "balance_neutrino_lock_interval"
let MinWavesSwapAmountKey = "min_waves_swap_amount"
let MinNeutrinoSwapAmountKey = "min_neutrino_swap_amount"
let NodeOracleProviderPubKeyKey = "node_oracle_provider"
let NeutrinoOutFeePartKey = "neutrinoOut_swap_feePart"
let WavesOutFeePartKey = "wavesOut_swap_feePart"
let FeesManagerAddressKey = "fees_manager_address"

#------Common----------------

#---Nodes Registry contract--
func keyNodeRegistry(address: String)       = "%s__" + address

#------Control contract-------
let PriceKey = "price"

let PriceIndexKey = "price_index"
let IsBlockedKey = "is_blocked"
func getPriceHistoryKey(block: Int) = PriceKey + "_" + toString(block)
func getHeightPriceByIndexKey(index: Int) = PriceIndexKey + "_" + toString(index)
func getStakingNodeByIndex(idx: Int) = getStringByKey(makeString(["%s%d%s", "lease", toString(idx), "nodeAddress"], SEP))
func getStakingNodeAddressByIndex(idx: Int) = addressFromStringValue(getStakingNodeByIndex(idx))

func getReservedAmountForSponsorship() =
    getInteger(this, makeString(["%s%s", "lease", "sponsorshipWavesReserve"], SEP)).valueOrElse(1000 * WAVELET)

#------This contract----------
#-------------------Keys-------------------
# TODO need to move into zero
func getBalanceUnlockBlockKey(owner: String)               = "balance_unlock_block_" + owner
func getLeaseIdKey(nodeIndex: Int)                         = makeString(["%s%d%s", "lease", toString(nodeIndex), "id"], SEP)
func getLeaseIdByAddressKey(nodeAddress: String)           = makeString(["%s%s%s", "leaseByAddress", nodeAddress, "id"], SEP)
func getLeaseAmountKey(nodeIndex: Int)                     = makeString(["%s%d%s", "lease", toString(nodeIndex), "amount"], SEP)
func getLeaseAmountByAddressKey(nodeAddress: String)       = makeString(["%s%s%s", "leaseByAddress", nodeAddress, "amount"], SEP)
func getLeaseGroupNodeListKey(groupNum: Int)               = makeString(["%s%d%s", "leaseGroup", groupNum.toString(), "nodeList"], SEP)

func minSwapAmountKEY(swapType: String)                    = "min_" + swapType + "_swap_amount"
func totalLockedKEY(swapType: String)                      = "balance_lock_" + swapType
func totalLockedByUserKEY(swapType: String, owner: String) = makeString(["balance_lock", swapType, owner], "_")
func balanceLockIntervalKEY(swapType: String)              = "balance_" + swapType + "_lock_interval" # number of blocks after user could withdraw funds
func nodeBalanceLockIntervalKEY()                          = "balance_node_lock_interval"
func outFeePartKEY(swapType: String)                       = swapType + "Out_swap_feePart"
func swapsTimeframeKEY()                                   = "swaps_timeframe"

#-------------------State Reading functions-------------------
func minSwapAmountREAD(swapType: String) = this.getInteger(minSwapAmountKEY(swapType)).valueOrElse(0)
func swapsTimeframeREAD() = this.getInteger(swapsTimeframeKEY()).valueOrElse(1440)
func totalLockedREAD(swapType: String) = this.getInteger(totalLockedKEY(swapType)).valueOrElse(0)
func totalLockedByUserREAD(swapType: String, owner: String) = this.getInteger(totalLockedByUserKEY(swapType, owner)).valueOrElse(0)
func balanceLockIntervalREAD(swapType: String) = this.getInteger(balanceLockIntervalKEY(swapType)).valueOrElse(1440) # number og blocks after user could withdraw funds
func nodeBalanceLockIntervalREAD() = this.getInteger(nodeBalanceLockIntervalKEY()).valueOrElse(1)
func keySwapUserSpentInPeriod(userAddress: String) = ["%s%s", "swapUserSpentInPeriod", userAddress].makeString(SEP)
func keyUserLastSwapHeight(userAddress: String) = ["%s%s", "userLastSwapHeight", userAddress].makeString(SEP)

func feeManagerAddressREAD() = this.getString(FeesManagerAddressKey)
          .valueOrErrorMessage(FeesManagerAddressKey + " is not specified")
          .addressFromString()
          .valueOrErrorMessage(FeesManagerAddressKey + " invalid address format")

#-------------------Convert functions-------------------
func convertNeutrinoToWaves(amount: Int, price: Int) = fraction(fraction(amount, PRICELET, price),WAVELET, PAULI)
func convertWavesToNeutrino(amount: Int, price: Int) = fraction(fraction(amount, price, PRICELET), PAULI, WAVELET)
func convertWavesToBond(amount: Int, price: Int) = convertWavesToNeutrino(amount, price) # it's here to be more explicit with convertation
func convertJsonArrayToList(jsonArray: String) = {
   jsonArray.split(",")
}

#-------------------Failures-------------------
func minSwapAmountFAIL(swapType: String, minSwapAmount: Int) = throw("The specified amount in " + swapType + " swap is less than the required minimum of " + toString(minSwapAmount))
func emergencyShutdownFAIL() = throw("contract is blocked by EMERGENCY SHUTDOWN actions untill reactivation by emergency oracles")

func priceIndexFAIL(index: Int, priceIndex: Int, indexHeight: Int, unlockHeight: Int, prevIndexHeight: Int) =
            throw("invalid price history index: index=" + toString(index)
                + " priceIndex=" + toString(priceIndex)
                + " indexHeight=" + toString(indexHeight)
                + " unlockHeight=" + toString(unlockHeight)
                + " prevIndexHeight=" + toString(prevIndexHeight))

#-------------------Global vars-------------------------

let liquidationContract = getStringByKey(LiquidationContractKey)
let nsbtStakingContractStr = getStringByKey(NsbtStakingContractKey)
let neutrinoAssetId = getStringByKey(NeutrinoAssetIdKey).fromBase58String()
let auctionContract = getStringByKey(AuctionContractKey)
let rpdContract = getStringByKey(RPDContractKey)
let controlContractStr = getStringByKey(ContolContractKey)
let controlContract = controlContractStr.addressFromStringValue()
let mathContractAddress = getStringByKey(MathContractKey)
let priceIndex = getNumberByAddressAndKey(controlContractStr, PriceIndexKey) # Last price history iterator from control.ride
let isBlocked = getBoolByAddressAndKey(controlContractStr,IsBlockedKey) # Checks for contract locks that might happen after attacks.  The var is read from control contract
let nodeOracleProviderPubKey = fromBase58String(getStringByKey(NodeOracleProviderPubKeyKey))
let bondAssetId = fromBase58String("6nSpVyNH7yM69eg446wrQR94ipbbcmZMU1ENPwanC97g") # NSBT with 6 decimals as USDN does
let deprecatedBondAssetId = fromBase58String("975akZBfnMj513U7MZaHKzQrmsEx5aE3wdWKTrHBhbjF") # USDNB with 0 decimals

let neutrinoContract = this
let mathContract = addressFromStringValue(mathContractAddress)
let nsbtStakingContract = addressFromStringValue(nsbtStakingContractStr)
#-------------------Global vars deficit, locked & supply -------------------------
let currentPrice = getNumberByAddressAndKey(controlContractStr, PriceKey) # The value from control.ride

#-------------------Verifier Functions----------------------
func checkIsValidMinSponsoredFee(tx: SponsorFeeTransaction) = {
    let MINTRANSFERFEE = 100000 #wavelets (to support smart assets)
    let SponsoredFeeUpperBound = 1000 # % of fee profits higther than real fee for transfer
    let realNeutrinoFee = convertWavesToNeutrino(MINTRANSFERFEE, currentPrice) # in paulis
    let minNeutrinoFee = realNeutrinoFee * 2 # 100%
    let maxNeutrinoFee = fraction(realNeutrinoFee, SponsoredFeeUpperBound, 100)

    let inputFee = tx.minSponsoredAssetFee.value()

    inputFee >= minNeutrinoFee && inputFee <= maxNeutrinoFee && tx.assetId == neutrinoAssetId
}

#------Control contract------
# The func is reading price from control.ride price history
func getPriceHistory(block: Int) = getNumberByAddressAndKey(controlContractStr, getPriceHistoryKey(block))
# The func is reading from control.ride price history heights
func getHeightPriceByIndex(index: Int) = getNumberByAddressAndKey(controlContractStr, getHeightPriceByIndexKey(index))

#------NSBT Staking contract------
func keyLockParamUserAmount(userAddress: String) = ["%s%s%s", "paramByUser", userAddress, "amount"].makeString(SEP)


#------This contract---------
let sIdxSwapType                 = 1
let sIdxStatus                   = 2
let sIdxInAmount                 = 3
let sIdxPrice                    = 4
let sIdxOutNetAmount             = 5
let sIdxOutFeeAmount             = 6
let sIdxStartHeight              = 7
let sIdxStartTimestamp           = 8
let sIdxEndHeight                = 9
let sIdxEndTimestamp             = 10
let sIdxSelfUnlockHeight         = 11
let sIdxRandUnlockHeight         = 12
let sIdxIndex                    = 13
let sIdxWithdrawTxId             = 14
let sIdxMinRand                  = 15
let sIdxMaxRand                  = 16

func swapKEY(userAddress: String, txId: String) = {
  makeString(["%s%s", userAddress, txId], SEP)
}

func strSwapDATA(swapType: String, status: String, inAmount: String, price: String, outNetAmount: String, outFeeAmount: String,
                 startHeight: String, startTimestamp: String, endHeight: String, endTimestamp: String,
                 selfUnlockHeight: String, randUnlockHeight: String, index: String, withdrawTxId: String,
                 randMin: String, randMax: String) = {
  makeString(["%s%s%d%d%d%d%d%d%d%d%d%d%d%s",
      swapType,                     # 1
      status,                       # 2
      inAmount,                     # 3
      price,                        # 4
      outNetAmount,                 # 5
      outFeeAmount,                 # 6
      startHeight,                  # 7
      startTimestamp,               # 8
      endHeight,                    # 9
      endTimestamp,                 # 10
      selfUnlockHeight,             # 11
      randUnlockHeight,             # 12
      index,                        # 13
      withdrawTxId,                 # 14
      randMin,                      # 15
      randMax                       # 16
      ],
  SEP)
}

func pendingSwapDATA(swapType: String, inAssetAmount: Int, selfUnlockHeight: Int) = {
  strSwapDATA(
      swapType,                       # 1
      "PENDING",                      # 2
      inAssetAmount.toString(),       # 3
      "0",                            # 4
      "0",                            # 5
      "0",                            # 6
      height.toString(),              # 7
      lastBlock.timestamp.toString(), # 8
      "0",                            # 9
      "0",                            # 10
      selfUnlockHeight.toString(),    # 11
      "0",                            # 12
      "0",                            # 13
      "NULL",                         # 14
      "0",                            # 15
      "0"                             # 16
  )
}

func finishSwapDATA(dataArray: List[String], price: Int, outNetAmount: Int, outFeeAmount: Int, randUnlockHeight: Int, index: Int, withdrawTxId: String) = {
  strSwapDATA(
      dataArray[sIdxSwapType],        # 1
      "FINISHED",                     # 2
      dataArray[sIdxInAmount],        # 3
      price.toString(),               # 4
      outNetAmount.toString(),        # 5
      outFeeAmount.toString(),        # 6
      dataArray[sIdxStartHeight],     # 7
      dataArray[sIdxStartTimestamp],  # 8
      height.toString(),              # 9
      lastBlock.timestamp.toString(), # 10
      dataArray[sIdxSelfUnlockHeight],# 11
      randUnlockHeight.toString(),    # 12
      index.toString(),               # 13
      withdrawTxId,                   # 14
      dataArray[sIdxMinRand],         # 15
      dataArray[sIdxMaxRand]          # 16
  )
}

func swapDataFailOrREAD(userAddress: String, swapTxId: String) = {
  let swapKey = swapKEY(userAddress, swapTxId)
  this.getString(swapKey)
    .valueOrErrorMessage("no swap data for " + swapKey)
    .split(SEP)
}

func applyFees(amountGross: Int, feePart: Int) = {
  let feeAmount = fraction(amountGross, feePart, PAULI)
  [amountGross - feeAmount, feeAmount, amountGross]
}

func abs(x: Int) = if (x < 0) then -x else x

func selectNode(unleaseAmount: Int) = {
    let amountToLease = wavesBalance(neutrinoContract).available - unleaseAmount - getReservedAmountForSponsorship()

    let oldLeased0 = getNumberByKey(getLeaseAmountKey(0))
    let oldLeased1 = getNumberByKey(getLeaseAmountKey(1))
    let newLeased0 = amountToLease + oldLeased0
    let newLeased1 = amountToLease + oldLeased1

    if (newLeased0 > 0 || newLeased1 > 0) then {
        # balancing the nodes
        let delta0 = abs(newLeased0 - oldLeased1)
        let delta1 = abs(newLeased1 - oldLeased0)
        # 0 node is a priority
        if (delta0 <= delta1) then (0, newLeased0) else (1, newLeased1)
    } else (-1, 0)
}

func thisOnly(i: Invocation) = {
  if (i.caller != this) then {
    throw("Permission denied: this contract only allowed")
  } else true
}

# prepare list of actions to lease available waves or cancel lease in case of usdn2waves swap
func prepareUnleaseAndLease(unleaseAmount: Int) = {
    let nodeTuple       = selectNode(unleaseAmount) # balancing waves by 2 nodes
    let nodeIndex       = nodeTuple._1
    let newLeaseAmount  = nodeTuple._2

    if (newLeaseAmount > 0) then {
        let leaseIdKey = getLeaseIdKey(nodeIndex)
        let oldLease = getBinary(this, leaseIdKey)
        let unleaseOrEmpty = if (oldLease.isDefined()) then [LeaseCancel(oldLease.value())] else []
        let leaseAmountKey = getLeaseAmountKey(nodeIndex)
        let lease = Lease(getStakingNodeAddressByIndex(nodeIndex), newLeaseAmount)

        unleaseOrEmpty ++ [
            lease,
            BinaryEntry(leaseIdKey, lcalc(lease)),
            IntegerEntry(getLeaseAmountKey(nodeIndex), newLeaseAmount)]
    } else []
}

func readNodeInfo(nodeIdx: Int) = {
  let nodeAddress = getStakingNodeAddressByIndex(nodeIdx)
  let leasedAmtKEY = getLeaseAmountKey(nodeIdx)
  let leasedAmt = leasedAmtKEY.getNumberByKey()

  let leaseIdKEY = getLeaseIdKey(nodeIdx)
  let leaseId = this.getBinary(leaseIdKEY).value()

  (nodeAddress, leasedAmtKEY, leasedAmt, leaseIdKEY, leaseId)
}

#-------------------MAIN LOGIC----------------------

func commonSwap(swapType: String, pmtAmount: Int, userAddressStr: String, txId58: String, swapParamsByUserSYSREADONLY: (Int,Int,Int,Int,Int)) = {
  let (swapLimitMax, swapLimitSpent, blcks2LmtReset) = swapParamsByUserSYSREADONLY

  let minSwapAmount         = minSwapAmountREAD(swapType)
  let totalLocked           = totalLockedREAD(swapType)
  let totalLockedByUser     = totalLockedByUserREAD(swapType, userAddressStr)
  let nodeAddress           = getStakingNodeByIndex(0)
  let priceByIndex          = priceIndex.getHeightPriceByIndex().getPriceHistory()
  let isSwapByNode          = nodeAddress == userAddressStr

  let balanceLockMaxInterval = if (isSwapByNode) then nodeBalanceLockIntervalREAD() else balanceLockIntervalREAD(swapType)
  let selfUnlockHeight       = height + balanceLockMaxInterval
  let swapUsdnVolume         = if (swapType == "neutrino") then pmtAmount else pmtAmount.convertWavesToNeutrino(priceByIndex)

  if (pmtAmount < minSwapAmount) then minSwapAmountFAIL(swapType, minSwapAmount) else
  if (!isSwapByNode && swapLimitSpent > 0) then throw("You have exceeded swap limit! Next allowed swap height is " + (height + blcks2LmtReset).toString()) else
  if (!isSwapByNode && swapUsdnVolume > swapLimitMax) then throw("You have exceeded your swap limit! Requested: "+ toString(swapUsdnVolume) + ", available: " + toString(swapLimitMax)) else
  if (isBlocked) then emergencyShutdownFAIL() else  # see control.ride

  let leasePart = if (swapType == "waves") then prepareUnleaseAndLease(0) else []

  ([
      IntegerEntry(keySwapUserSpentInPeriod(userAddressStr), swapUsdnVolume),
      IntegerEntry(keyUserLastSwapHeight(userAddressStr), height),
      IntegerEntry(totalLockedByUserKEY(swapType, userAddressStr), totalLockedByUser + pmtAmount),
      IntegerEntry(getBalanceUnlockBlockKey(userAddressStr), selfUnlockHeight),
      IntegerEntry(totalLockedKEY(swapType), totalLocked + pmtAmount),
      StringEntry(
        swapKEY(userAddressStr, txId58),
        pendingSwapDATA(swapType, pmtAmount, selfUnlockHeight))
    ] ++ leasePart, unit)

}

func commonWithdraw(account : String, index: Int, swapTxId: String, withdrawTxId: String) = {
    let userAddress = addressFromStringValue(account)
    let feeManagerAddress = feeManagerAddressREAD()

    let dataArray         = swapDataFailOrREAD(account, swapTxId)
    let selfUnlockHeight  = dataArray[sIdxSelfUnlockHeight].parseIntValue()
    let swapType          = dataArray[sIdxSwapType]
    let inAmount          = dataArray[sIdxInAmount].parseIntValue()
    let swapStatus        = dataArray[sIdxStatus]
    let startHeight       = dataArray[sIdxStartHeight].parseIntValue()

    let outFeePart        = this.getInteger(outFeePartKEY(swapType)).valueOrElse(DEFAULTSWAPFEE)
    let totalLocked       = totalLockedREAD(swapType)
    let totalLockedByUser = totalLockedByUserREAD(swapType, account)

    let unlockHeight = selfUnlockHeight

    let indexHeight = getHeightPriceByIndex(index)
    let prevIndexHeight = getHeightPriceByIndex(index-1)
    let priceByIndex = getPriceHistory(indexHeight)

    let outAmountGrossTuple =
        if (swapType == "waves")    then (convertWavesToNeutrino(inAmount, priceByIndex), neutrinoAssetId) else
        if (swapType == "neutrino") then (convertNeutrinoToWaves(inAmount, priceByIndex), unit) else
        throw("Unsupported swap type " + swapType)

    let payoutsArray = applyFees(outAmountGrossTuple._1, outFeePart)
    let outNetAmount = payoutsArray[IdxNetAmount]
    let outFeeAmount = payoutsArray[IdxFeeAmount]

    if (isBlocked) then emergencyShutdownFAIL() else
    if (swapStatus != "PENDING") then throw("swap has been already processed") else
    if (unlockHeight > height) then throw("please wait for: " + toString(unlockHeight) + " block height to withdraw funds") else
    if (index > priceIndex
          || indexHeight < unlockHeight
          || (prevIndexHeight != 0 && unlockHeight <= prevIndexHeight)) then priceIndexFAIL(index, priceIndex, indexHeight, unlockHeight, prevIndexHeight) else
    if (payoutsArray[IdxGrossAmount] <= 0) then throw("balance equals zero") else
    if (outFeePart < 0 || outFeePart >= PAULI) then throw("invalid outFeePart config for " + swapType + " swap: outFeePart=" + outFeePart.toString()) else

    let unleaseAmount = if (swapType == "neutrino" && outAmountGrossTuple._1 > 0) then outAmountGrossTuple._1 else 0

    let state = [
      IntegerEntry(totalLockedByUserKEY(swapType, account), totalLockedByUser - inAmount),
      IntegerEntry(totalLockedKEY(swapType), totalLocked - inAmount),
      ScriptTransfer(userAddress, outNetAmount, outAmountGrossTuple._2),
      StringEntry(
        swapKEY(account, swapTxId),
        finishSwapDATA(dataArray, priceByIndex, outNetAmount, outFeeAmount, unlockHeight, index, withdrawTxId))
    ]

    (state, AttachedPayment(outAmountGrossTuple._2, outFeeAmount), unleaseAmount)
}

#-------------------Callable----------------------

@Callable(i)
func constructor(
  neutrinoAssetIdPrm: String,
  bondAssetIdPrm: String,
  auctionContractPrm: String,
  liquidationContractPrm: String,
  rpdContractPrm: String,
  nodeOracleProviderPubKeyPrm: String,
  balanceWavesLockIntervalPrm: Int,
  balanceNeutrinoLockIntervalPrm: Int,
  minWavesSwapAmountPrm: Int,
  minNeutrinoSwapAmountPrm: Int,
  neutrinoOutFeePartPrm: Int,
  wavesOutFeePartPrm: Int) = {

  strict checkCaller = i.thisOnly()
  if (i.payments.size() != 0) then throw("no payments allowed") else

  [
    StringEntry(NeutrinoAssetIdKey, neutrinoAssetIdPrm),
    StringEntry(BondAssetIdKey, bondAssetIdPrm),
    StringEntry(AuctionContractKey, auctionContractPrm),
    StringEntry(LiquidationContractKey, liquidationContractPrm),
    StringEntry(RPDContractKey, rpdContractPrm),
    StringEntry(NodeOracleProviderPubKeyKey, nodeOracleProviderPubKeyPrm),
    IntegerEntry(BalanceWavesLockIntervalKey, balanceWavesLockIntervalPrm),
    IntegerEntry(BalanceNeutrinoLockIntervalKey, balanceNeutrinoLockIntervalPrm),
    IntegerEntry(MinWavesSwapAmountKey, minWavesSwapAmountPrm),
    IntegerEntry(MinNeutrinoSwapAmountKey, minNeutrinoSwapAmountPrm),
    IntegerEntry(NeutrinoOutFeePartKey, neutrinoOutFeePartPrm),
    IntegerEntry(WavesOutFeePartKey, wavesOutFeePartPrm)
  ]
}

@Callable(i)
func constructorV2(mathContract: String, nsbtStakingContract: String, swapsTimeframeBlocks: Int) = {
  strict checkCaller = i.thisOnly()
  if (i.payments.size() != 0) then throw("no payments allowed") else
  [
    StringEntry(MathContractKey, mathContract),
    StringEntry(NsbtStakingContractKey, nsbtStakingContract),
    IntegerEntry(swapsTimeframeKEY(), swapsTimeframeBlocks)
  ]
}

# Instant swap of WAVES to Neutrino token at the current price on the smart contract
# [called by user]
@Callable(i)
func swapWavesToNeutrino() = {
    if (i.payments.size() != 1) then throw("swapWavesToNeutrino require only one payment") else
    let pmt = i.payments[0].value()
    if (isDefined(pmt.assetId)) then throw("Only Waves token is allowed for swapping.") else

    let userAddress = i.caller.toString()
    let txId58 = i.transactionId.toBase58String()

    let swapParamsSTRUCT = this.invoke("swapParamsByUserSYSREADONLY", [userAddress, 0], []).asSwapParamsSTRUCT()

    let commonSwapResult =  commonSwap("waves", pmt.amount, userAddress, txId58, swapParamsSTRUCT)
    commonSwapResult
}

# Swap request of Neutrino to WAVES. After {balanceLockInterval} blocks, WAVES tokens will be available for withdrawal
# via {withdraw(account : String)} method at the price that is current at the time when {balanceLockInterval} is reached
# [called by user]
@Callable(i)
func swapNeutrinoToWaves() = {
    if (i.payments.size() != 1) then throw("swapNeutrinoToWaves require only one payment") else
    let pmt = i.payments[0].value()
    if (pmt.assetId != neutrinoAssetId) then throw("Only appropriate Neutrino tokens are allowed for swapping.") else

    let userAddress = i.caller.toString()
    let txId58 = i.transactionId.toBase58String()

    let swapParamsSTRUCT = this.invoke("swapParamsByUserSYSREADONLY", [userAddress, 0], []).asSwapParamsSTRUCT()

    let commonSwapResult = commonSwap("neutrino", pmt.amount, userAddress, txId58, swapParamsSTRUCT)
    commonSwapResult
}

# Withdraw WAVES from smart contract after {swapNeutrinoToWaves()} request has reached {balanceLockInterval} height
# at the price that is current at the time when {balanceLockInterval} is reached
# [called by user]
@Callable(i)
func withdraw(account: String, index: Int, swapTxId: String) = {
    let txId = i.transactionId.toBase58String()
    if (i.payments.size() != 0) then throw("no payments allowed") else

    let commonTuple = commonWithdraw(account, index, swapTxId, txId)
    let state       = commonTuple._1
    let fee         = commonTuple._2
    let unleaseAmt  = commonTuple._3

    strict unleaseInvOrEmpty = this.invoke("internalUnleaseAndLease", [unleaseAmt], [])

    if (fee.amount <= 0) then state else
    strict nsbtStakingReward = nsbtStakingContract.invoke("deposit", [], [fee])
    state
}

@Callable(i)
func internalUnleaseAndLease(unleaseAmount: Int) = {
  if (i.caller != this) then throw("internalUnleaseAndLease is not public method") else
  prepareUnleaseAndLease(unleaseAmount)
}

# Callback for auction contract to transfer USDN to user
@Callable(i)
func transferUsdnToUser(amount: Int, addr: String) = {
    if (i.caller != addressFromStringValue(auctionContract)) then throw("Only auction contract is authorized") else

    [ScriptTransfer(addressFromStringValue(addr), amount, neutrinoAssetId)]
}

# Accept waves from auction.ride after buyNsbt() to lease them immediately
@Callable(i)
func acceptWaves() = {
    if (i.caller != addressFromStringValue(auctionContract))
        then throw("Currently only auction contract is allowed to call")
    else
        (prepareUnleaseAndLease(0), "success")
}

@Callable(i)
func approveLeasings(nListS: String, groupNum: Int) = {
  let lAmt = 500_000 * WAVELET
  let nIdxs = [0, 1, 2, 3, 4, 5, 6, 7]

  let mngPubS = getString("%s%s__cfg__leasingManagerPub").valueOrElse("7AUMX54ukYMYvPmma7yoFf5NjZhs4Bu5nz3Ez9EV8sur")
  let mngPub = mngPubS.fromBase58String()

  let nodeRegAddrStr = getString("%s%s__cfg__nodesRegistryAddress").valueOrElse("3P9vKqQKjUdmpXAfiWau8krREYAY1Xr69pE")
  let nodeRegAddr = nodeRegAddrStr.addressFromStringValue()

  let lGroupNodeListKEY = getLeaseGroupNodeListKey(groupNum)
  let lGrNodeOpt = this.getString(lGroupNodeListKEY)
  if (lGrNodeOpt.isDefined()) then throw("group " + groupNum.toString() + " already initialized") else

  let nList = nListS.split(SEP)
  let expCount = nIdxs.size()

  if (i.callerPublicKey != mngPub) then throw("approveLeasings not authorized") else

  let (nAddr0, lAmtKEY0, lAmt0, lIdKEY0, lId0) = readNodeInfo(0)
  let (nAddr1, lAmtKEY1, lAmt1, lIdKEY1, lId1) = readNodeInfo(1)

  let newL0 = Lease(nAddr0, lAmt0 - lAmt * expCount / 2)
  let newL1 = Lease(nAddr1, lAmt1 - lAmt * expCount / 2)

  strict validation = nodeRegAddr.invoke("validateAndApproveLeasings", [nListS], [])

  func forEachNodeValidateAndGenerateLease(a: List[Lease|BinaryEntry|IntegerEntry], i: Int) = {
    let node = nList[i]
    let la = Lease(node.addressFromStringValue(), lAmt)
    a++[la,
        BinaryEntry(getLeaseIdByAddressKey(node), lcalc(la)),
        IntegerEntry(getLeaseAmountByAddressKey(node), lAmt)]
  }

  [StringEntry(lGroupNodeListKEY, nListS),
    BinaryEntry(lIdKEY0, lcalc(newL0)),
    BinaryEntry(lIdKEY1, lcalc(newL1)),
    IntegerEntry(lAmtKEY0, newL0.amount),
    IntegerEntry(lAmtKEY1, newL1.amount),
    LeaseCancel(lId0),
    LeaseCancel(lId1),
    newL0,
    newL1
  ]
    ++ FOLD<8>(nIdxs, [], forEachNodeValidateAndGenerateLease)
}

# READONLY methods
@Callable(i)
func swapParamsByUserSYSREADONLY(userAddressStr: String, nsbtDiff: Int) = {
  strict nsbtData = nsbtStakingContract.invoke("nsbtStakingSYSREADONLY", [userAddressStr], []).asAnyList()
  let gnsbtAmt = nsbtData[0].asInt() + nsbtDiff
  let gnsbtAmtTotal = nsbtData[1].asInt() + nsbtDiff

  let swapLimitMax = mathContract.invoke("calcSwapLimitREADONLY", [gnsbtAmt], []).asInt()

  let lastSwapHeight = this.getInteger(keyUserLastSwapHeight(userAddressStr)).valueOrElse(0)
  let swapLimitTimelifeBlocks = swapsTimeframeREAD()
  let passedBlocksAfterLastSwap = height - lastSwapHeight
  let isSwapTimelifeNew = passedBlocksAfterLastSwap >= swapLimitTimelifeBlocks
  let swapLimitSpent = if (isSwapTimelifeNew) then 0 else this.getInteger(keySwapUserSpentInPeriod(userAddressStr)).valueOrElse(0)
  let blcks2LmtReset = if (isSwapTimelifeNew) then 0 else swapLimitTimelifeBlocks - passedBlocksAfterLastSwap

  # WARNING if you change returned value - MUST have to change "asSwapParamsSTRUCT" function
  ([], (swapLimitMax, swapLimitSpent, blcks2LmtReset, gnsbtAmt, gnsbtAmtTotal))
}

@Verifier(tx)
 func verify() = {
    let id = toBase58String(tx.id)

    let pubKeyAdminsListStr = makeString([
        "GJdLSaLiv5K7xuejac8mcRcHoyo3dPrESrvktG3a6MAR",
        "EYwZmURd5KKaQRBjsVa6g8DPisFoS6SovRJtFiL5gMHU",
        "DtmAfuDdCrHK8spdAeAYzq6MsZegeD9gnsrpuTRkCbVA",
        "5WRXFSjwcTbNfKcJs8ZqXmSSWYsSVJUtMvMqZj5hH4Nc"
    ], SEP)

    let pubKeyAdminsList = controlContract.getString("%s__multisig")
          .valueOrElse(pubKeyAdminsListStr)
          .split(SEP)

    let count =
        (if(sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String(pubKeyAdminsList[0]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[1], fromBase58String(pubKeyAdminsList[1]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[2], fromBase58String(pubKeyAdminsList[2]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[3], fromBase58String(pubKeyAdminsList[3]))) then 2 else 0)
    match tx {
        case sponsorTx: SponsorFeeTransaction =>
            checkIsValidMinSponsoredFee(sponsorTx) && count >= 3
        case _ => {
            count >= 3
        }
    }
}
