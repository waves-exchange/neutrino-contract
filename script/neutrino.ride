{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
#
# Main Smart Contract of Neutrino Protocol
# Implemented actions: Swap, Bond Liquidation, Leasing
#
let revisionNum = ""

#-------------------Base functions----------------------
func getStringOrFail(address: Address, key: String)  = address.getString(key).valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))

# workaround to reduce size
func lcalc(l: Lease) = {
  calculateLeaseId(l)
}

func getNumberByKey(key: String) = {
    getInteger(this, key).valueOrElse(0)
}
func getStringByKey(key: String) = {
    getString(this, key).valueOrElse("")
}
func getBoolByKey(key: String) = {
    getBoolean(this, key).valueOrElse(false)
}
func getNumberByAddressAndKey(address: Address, key: String) = {
    getInteger(address, key).valueOrElse(0)
}
func getStringByAddressAndKey(address: String, key: String) = {
     getString(addressFromStringValue(address), key).valueOrElse("")
}
func getBoolByAddressAndKey(address: Address, key: String) = {
     getBoolean(address, key).valueOrElse(false)
}
func asAnyList(v: Any) = {
  match v {
    case l: List[Any] => l
    case _ => throw("fail to cast into List[Any]")
  }
}
func asString(v: Any) = {
  match v {
    case s: String => s
    case _ => throw("fail to cast into String")
  }
}
func asInt(v: Any) = {
  match v {
    case i: Int => i
    case _ => throw("fail to cast into Int")
  }
}
func asBytes(val: Any) = {
  match val {
    case valByte: ByteVector => valByte
    case _ => throw("fail to cast into ByteVector")
  }
}
func asPayment(v: Any) = {
  match v {
    case p: AttachedPayment => p
    case _ => throw("fail to cast into AttachedPayment")
  }
}

func asSwapParamsSTRUCT(v: Any) = {
  match v {
    case struct: (Int, Int, Int, Int, Int, Int, Int) => struct
    case _ => throw("fail to cast into Tuple5 ints")
  }
}

func removeFromListStr(listStr: String, separator: String, strToRemove: String) = {
  let arr = listStr.split(separator)
  let idx = arr.indexOf(strToRemove).valueOrErrorMessage(listStr + "does not contain " + strToRemove)
  arr.removeByIndex(idx).makeString(separator)
}

#-------------------Constants---------------------------
let SEP = "__"
let LISTSEP = ":"
let MULT8 = 1_0000_0000
let MULT6 = 1_000_000
let DEFAULTSWAPFEE = 20000 # 0.02 * 1000000 or 2%
let DEFAULTBURNFEE = 5000 # xtn to basket (burn) default protocol fee, 0.005 or 0.5%
let DEFAULTMAXFEE = 150000 # 0.15 or 15%
let BRPROTECTED = 100000 # if BR <= 10% then use SURF during swap USDN->WAVES
let WAVESID = base58'WAVES'

#indices for calcNeutinoMetricsREADONLY result array
let nMetricIdxPrice = 0
let nMetricIdxUsdnLockedBalance = 1
let nMetricIdxWavesLockedBalance = 2
let nMetricIdxReserve = 3
let nMetricIdxReserveInUsdn = 4
let nMetricIdxUsdnSupply = 5
let nMetricIdxSurplus = 6
let nMetricIdxSurplusPercent = 7
let nMetricIdxBR = 8 # BR with 6 decimals
let nMetricIdxNsbtSupply = 9
let nMetricIdxMaxNsbtSupply = 10
let nMetricIdxSurfSupply = 11
let nMetricUsdnUsdtPeg = 12
let nMetricCurrentPriceAdj = 13
let nMetricBasketInfo = 14
let nMetricWeightedPrice = 15
let nMetricTotalReservesUsd = 16

# data indices from controlConfig
let IdxControlCfgNeutrinoDapp     = 1
let IdxControlCfgAuctionDapp      = 2
let IdxControlCfgRpdDapp          = 3
let IdxControlCfgMathDapp         = 4
let IdxControlCfgLiquidationDapp  = 5
let IdxControlCfgRestDapp         = 6
let IdxControlCfgNodeRegistryDapp = 7
let IdxControlCfgNsbtStakingDapp  = 8
let IdxControlCfgMediatorDapp     = 9
let IdxControlCfgSurfStakingDapp  = 10
let IdxControlCfgGnsbtControllerDapp = 11
let IdxControlCfgRestV2Dapp       = 12
let IdxControlCfgGovernanceDapp   = 13

func keyControlAddress() = "%s%s__config__controlAddress"
func keyControlCfg()     = "%s__controlConfig"

func readControlCfgOrFail(control: Address) = split_4C(control.getStringOrFail(keyControlCfg()), SEP)
func getContractAddressOrFail(controlCfg: List[String], idx: Int) = controlCfg[idx].addressFromString()
  .valueOrErrorMessage("Control cfg doesn't contain address at index " + idx.toString())

# GLOBAL VARIABLES
let controlContract = this.getString(keyControlAddress()).valueOrElse("3P5Bfd58PPfNvBM2Hy8QfbcDqMeNtzg7KfP").addressFromStringValue()
let controlCfg = controlContract.readControlCfgOrFail()
let mathContract = controlCfg.getContractAddressOrFail(IdxControlCfgMathDapp)
let nsbtStakingContract = controlCfg.getContractAddressOrFail(IdxControlCfgNsbtStakingDapp)
let surfStakingContract = controlCfg.getContractAddressOrFail(IdxControlCfgSurfStakingDapp)
let gnsbtControllerContract = controlCfg.getContractAddressOrFail(IdxControlCfgGnsbtControllerDapp)
let auctionContract = controlCfg.getContractAddressOrFail(IdxControlCfgAuctionDapp)
let nodeRegistryContract = controlCfg.getContractAddressOrFail(IdxControlCfgNodeRegistryDapp)
let govContract = controlCfg.getContractAddressOrFail(IdxControlCfgGovernanceDapp)

#-------------------Constructor-------------------------
let NeutrinoAssetIdKey = "neutrino_asset_id"
let BondAssetIdKey = "bond_asset_id"
let AuctionContractKey = "auction_contract"
let NsbtStakingContractKey = "nsbtStakingContract"
let LiquidationContractKey = "liquidation_contract"
let RPDContractKey = "rpd_contract"
let ContolContractKey = "control_contract"
let MathContractKey = "math_contract"
let BalanceWavesLockIntervalKey = "balance_waves_lock_interval"
let BalanceNeutrinoLockIntervalKey = "balance_neutrino_lock_interval"
func MinTokenSwapAmountKey(assetId: String) = "min_outNeutrino_swap_amount_" + assetId
let MinNeutrinoSwapAmountKey = "min_outMulti_swap_amount"
let LegacyMinNeutrinoSwapAmountKey = "min_neutrino_swap_amount"
let NodeOracleProviderPubKeyKey = "node_oracle_provider"
let NeutrinoOutFeePartKey = "neutrinoOut_swap_feePart" # master protocol fee, on top of (1 + d)
let WavesOutFeePartKey = "wavesOut_swap_feePart" # legacy protocol fee, used as default value for BasketOutFeePartKey
let BasketOutFeePartKey = "multiOut_swap_feePart" # Protocol fee (after deduction of k*D, to pay gNSBT stakers)

#------Common----------------

#---Nodes Registry contract--
func keyNodeRegistry(address: String)       = "%s__" + address

#------Control contract-------
let PriceKey = "price"

let PriceIndexKey = "price_index"
let IsBlockedKey = "is_blocked"
let IsDisabledIssueKey = "xtn_issue_disabled"
func getPriceHistoryKey(block: Int) = PriceKey + "_" + toString(block)
func getHeightPriceByIndexKey(index: Int) = PriceIndexKey + "_" + toString(index)
func getStakingNodeByIndex(idx: Int) = getStringByKey(makeString(["%s%d%s", "lease", toString(idx), "nodeAddress"], SEP))
func getStakingNodeAddressByIndex(idx: Int) = addressFromStringValue(getStakingNodeByIndex(idx))

func getReservedAmountForSponsorship() =
    getInteger(this, makeString(["%s%s", "lease", "sponsorshipWavesReserve"], SEP)).valueOrElse(1000 * MULT8)

#------This contract----------
#-------------------Keys-------------------
# TODO need to move into zero
func getBalanceUnlockBlockKey(owner: String)               = "balance_unlock_block_" + owner
func getLeaseIdKey(nodeIndex: Int)                         = makeString(["%s%d%s", "lease", toString(nodeIndex), "id"], SEP)
func getLeaseIdByAddressKey(nodeAddress: String)           = makeString(["%s%s%s", "leaseByAddress", nodeAddress, "id"], SEP)
func getLeaseAmountKey(nodeIndex: Int)                     = makeString(["%s%d%s", "lease", toString(nodeIndex), "amount"], SEP)
func getLeaseAmountByAddressKey(nodeAddress: String)       = makeString(["%s%s%s", "leaseByAddress", nodeAddress, "amount"], SEP)
func getLeaseGroupNodeListKey(groupNum: Int)               = makeString(["%s%d%s", "leaseGroup", groupNum.toString(), "nodeList"], SEP)

func minSwapAmountKEY(swapType: String)                    = "min_" + swapType + "_swap_amount"
func totalLockedKEY(swapType: String, assetId: String)     = makeString(["%s%s%s", "balanceLock", swapType, assetId], SEP)
func totalLockedByUserKEY(swapType: String, owner: String, assetId: String) = makeString(["%s%s%s%s", "balanceLock", swapType, owner, assetId], "_")
func balanceLockIntervalKEY(swapType: String) = { # number of blocks after which user could withdraw funds
  if (swapType == "outMulti") then BalanceNeutrinoLockIntervalKey else BalanceWavesLockIntervalKey
}
func nodeBalanceLockIntervalKEY()                          = "balance_node_lock_interval"
func swapsTimeframeKEY()                                   = "swaps_timeframe"
func brProtectedKEY()                                      = "min_BR_protection_level"
#---------------- xtn multi-asset basket keys -----------------
func basketAssetsKey()                                     = "%s%s__common__basketAssets"
func basketDKey()                                          = "%s%s__common__basketD"
func basketKKey()                                          = "%s%s__common__basketK"
func basketBKey()                                          = "%s%s__common__basketB"
func basketLogbDeltaKey()                                  = "%s%s__common__basketLogbDelta"
func basketWeightByAssetKey(assetId: String)               = "%s%s%s__common__weightByAsset__" + assetId
func keyPriceByAsset(assetId: String)                      = "%s%s%s__common__priceByAsset__" + assetId
func maxFeeKey()                                           = "%s%s__common__maxAllowedFee"

#-------------------State Reading functions-------------------
func multiOutFeeREAD() = getInteger(BasketOutFeePartKey).valueOrElse(getInteger(WavesOutFeePartKey).valueOrElse(DEFAULTBURNFEE))
func minSwapAmountREAD(swapType: String, assetId: String) = {
  if (swapType == "outMulti") then getInteger(MinNeutrinoSwapAmountKey).valueOrElse(getNumberByKey(LegacyMinNeutrinoSwapAmountKey))
  else getNumberByKey(MinTokenSwapAmountKey(assetId))
}
func swapsTimeframeREAD() = this.getInteger(swapsTimeframeKEY()).valueOrElse(1440)
func totalLockedREAD(swapType: String, assetId: String) = this.getInteger(totalLockedKEY(swapType, assetId)).valueOrElse(0)
func totalLockedByUserREAD(swapType: String, owner: String, assetId: String) = this.getInteger(totalLockedByUserKEY(swapType, owner, assetId)).valueOrElse(0)
func balanceLockIntervalREAD(swapType: String) = this.getInteger(balanceLockIntervalKEY(swapType)).valueOrElse(1440) # number og blocks after user could withdraw funds
func nodeBalanceLockIntervalREAD() = this.getInteger(nodeBalanceLockIntervalKEY()).valueOrElse(1)
func keySwapUserSpentInPeriod(userAddress: String) = ["%s%s", "swapUserSpentInPeriod", userAddress].makeString(SEP)
func keyUserLastSwapHeight(userAddress: String) = ["%s%s", "userLastSwapHeight", userAddress].makeString(SEP)

#-------------------Convert functions-------------------
func convertNeutrinoToWaves(amount: Int, price: Int) = fraction(amount, MULT8, price)
func convertTokenToUsd(amount: Int, price: Int) = fraction(amount, price, MULT8)
func convertWavesToNeutrino(amount: Int, price: Int) = fraction(amount, price, MULT8) # for tests compatibility only
func convertWavesToBond(amount: Int, price: Int) = convertTokenToUsd(amount, price) # it's here to be more explicit with convertation
func convertJsonArrayToList(jsonArray: String) = {
   jsonArray.split(",")
}

func convertBasketItemToNeutrino(inAmount: Int, inAsset: String, basketInfoStr: String, neutrinoPrice: Int) = {
  let basketInfo = split_4C(basketInfoStr, "_")
  # basket item: assetIdStr:share6:price6:reserve8
  func findItem(acc: List[String], item: String) = {
    let bItem = item.split(LISTSEP)
    if (bItem[0] == inAsset) then bItem else acc
  }
  let it = FOLD<10>(basketInfo, [], findItem) # [assetIdStr, share6, price6, reserve8]
  # xntOut = inAmount * price[i] / xntPrice * (1 + D - b^(dlog - w[i] + x[i]))
  let dlog6 = getInteger(basketLogbDeltaKey()).value()
  let d6 = getInteger(basketDKey()).value()
  let b6 = getInteger(basketBKey()).value()
  let w6 = getInteger(basketWeightByAssetKey(inAsset)).value()
  let p6 = dlog6 - w6 + it[1].parseIntValue()
  let pp6 = pow(b6, 6, p6, 6, 6, HALFUP)
  # initially there is no supply and no reserve, so we assume xntPrice = 1
  let outAmountGross = fraction(inAmount, it[2].parseIntValue(), if (neutrinoPrice == 0) then MULT8 else neutrinoPrice * 100)
  let multiplier = MULT6 + d6 - pp6 # can be 1+D .. 1 .. 0 .. -inf
  if (multiplier <= 0) then throw("Non-positive multiplier = " + multiplier.toString()) else
  # condition "multiplier > (1 - maxAllowedFee)" is checked during swap stage only
  let discounted = fraction(outAmountGross, multiplier, MULT6)
  let masterFee = getInteger(NeutrinoOutFeePartKey).valueOrElse(DEFAULTSWAPFEE)
  let feeAmount = fraction(discounted, masterFee, MULT6)
  [discounted, discounted - feeAmount, feeAmount, multiplier] # [grossAmount, netAmount, feeAmount, multiplier]
}

# Up to 10 assets
func convertNeutrinoToBasket(amount: Int, basketInfoStr: String, neutrinoSupply: Int) = {
  let basketInfo = split_4C(basketInfoStr, "_")
  let k6 = getInteger(basketKKey()).value()
  let d6 = getInteger(basketDKey()).value()
  let outPart = MULT6 - fraction(k6, d6, MULT6) # for outMulti swaps, k*D part stays in reserves, and (1 - k*D) after applying fee goes to user
  # basket item: assetIdStr:share6:price6:reserve8
  func conv(acc: (List[(String, Int, Int, Int)], Int, Int), item: String) = {
    let parts = item.split(LISTSEP)
    let assetId = parts[0]
    let share = parts[1].parseIntValue()
    let price = parts[2].parseIntValue()
    let reserv = parts[3].parseIntValue()
    if (neutrinoSupply == 0) then throw("Attempt to burn neutrino at zero supply") else
    let outAmount = fraction(fraction(amount, reserv, neutrinoSupply), outPart, MULT6) # amount * (1 - k*D)
    let wavesTuple = if (assetId == "WAVES") then (outAmount, price) else (acc._2, acc._3)
    (acc._1 :+ (assetId, outAmount, price, share), wavesTuple._1, wavesTuple._2)
  }
  FOLD<10>(basketInfo, ([], 0, 0), conv) # (List[(assetId, outAmount, price, share)], wavesOutAmount, wavesPrice)
}

#-------------------Failures-------------------
func minSwapAmountFAIL(swapType: String, minSwapAmount: Int) = throw("The specified amount in " + swapType + " swap is less than the required minimum of " + toString(minSwapAmount))
func emergencyShutdownFAIL() = throw("contract is blocked by EMERGENCY SHUTDOWN actions untill reactivation by emergency oracles")

func priceIndexFAIL(index: Int, priceIndex: Int, indexHeight: Int, unlockHeight: Int, prevIndexHeight: Int) =
            throw("invalid price history index: index=" + toString(index)
                + " priceIndex=" + toString(priceIndex)
                + " indexHeight=" + toString(indexHeight)
                + " unlockHeight=" + toString(unlockHeight)
                + " prevIndexHeight=" + toString(prevIndexHeight))

#-------------------Global vars-------------------------

let neutrinoAssetId = getStringByKey(NeutrinoAssetIdKey).fromBase58String()
let priceIndex = getNumberByAddressAndKey(controlContract, PriceIndexKey) # Last price history iterator from control.ride
let isBlocked = getBoolByAddressAndKey(controlContract, IsBlockedKey) # Checks for contract locks that might happen after attacks.  The var is read from control contract
let isDisabledIssueXtn = getBoolByAddressAndKey(controlContract, IsDisabledIssueKey)
let nodeOracleProviderPubKey = fromBase58String(getStringByKey(NodeOracleProviderPubKeyKey))
let bondAssetId = fromBase58String("6nSpVyNH7yM69eg446wrQR94ipbbcmZMU1ENPwanC97g") # NSBT with 6 decimals as USDN does
let deprecatedBondAssetId = fromBase58String("975akZBfnMj513U7MZaHKzQrmsEx5aE3wdWKTrHBhbjF") # USDNB with 0 decimals

let neutrinoContract = this
#-------------------Global vars deficit, locked & supply -------------------------
let currentPrice = getNumberByAddressAndKey(controlContract, PriceKey) # The value from control.ride

#-------------------Verifier Functions----------------------
func checkIsValidMinSponsoredFee(tx: SponsorFeeTransaction) = {
    let MINTRANSFERFEE = 100000 #wavelets (to support smart assets)
    let SponsoredFeeUpperBound = 1000 # % of fee profits higther than real fee for transfer
    let realNeutrinoFee = convertTokenToUsd(MINTRANSFERFEE, currentPrice) # in paulis
    let minNeutrinoFee = realNeutrinoFee * 2 # 100%
    let maxNeutrinoFee = fraction(realNeutrinoFee, SponsoredFeeUpperBound, 100)

    let inputFee = tx.minSponsoredAssetFee.value()

    inputFee >= minNeutrinoFee && inputFee <= maxNeutrinoFee && tx.assetId == neutrinoAssetId
}

#------Control contract------
# The func is reading price from control.ride price history
func getPriceHistory(block: Int) = getNumberByAddressAndKey(controlContract, getPriceHistoryKey(block))
# The func is reading from control.ride price history heights
func getHeightPriceByIndex(index: Int) = getNumberByAddressAndKey(controlContract, getHeightPriceByIndexKey(index))

#------NSBT Staking contract------
func keyLockParamUserAmount(userAddress: String) = ["%s%s%s", "paramByUser", userAddress, "amount"].makeString(SEP)


#------This contract---------
let sIdxSwapType                 = 1
let sIdxStatus                   = 2
let sIdxInAmount                 = 3
let sIdxStartHeight              = 7
let sIdxStartTimestamp           = 8
let sIdxSelfUnlockHeight         = 11
let sIdxMinRand                  = 15
let sIdxMaxRand                  = 16
let sIdxInAsset                  = 20

func swapKEY(userAddress: String, txId: String) = {
  makeString(["%s%s", userAddress, txId], SEP)
}

func strSwapDATA(swapType: String, status: String, inAmount: String, price: String, outNetAmount: String, outFeeAmount: String,
                 startHeight: String, startTimestamp: String, endHeight: String, endTimestamp: String,
                 selfUnlockHeight: String, randUnlockHeight: String, index: String, withdrawTxId: String,
                 randMin: String, randMax: String, outSurfAmt: String, br: String, basketData: String, inAsset: String) = {
  makeString_2C(["%s%s%d%d%d%d%d%d%d%d%d%d%d%s%d%d%d%d%s%s", # 0
      swapType,                     # 1
      status,                       # 2
      inAmount,                     # 3
      price,                        # 4
      outNetAmount,                 # 5
      outFeeAmount,                 # 6
      startHeight,                  # 7
      startTimestamp,               # 8
      endHeight,                    # 9
      endTimestamp,                 # 10
      selfUnlockHeight,             # 11
      randUnlockHeight,             # 12
      index,                        # 13
      withdrawTxId,                 # 14
      randMin,                      # 15
      randMax,                      # 16
      outSurfAmt,                   # 17
      br,                           # 18
      basketData,                   # 19
      inAsset                       # 20
      ],
  SEP)
}

func pendingSwapDATA(swapType: String, inAssetAmount: Int, selfUnlockHeight: Int, inAsset: String) = {
  strSwapDATA(
      swapType,                       # 1
      "PENDING",                      # 2
      inAssetAmount.toString(),       # 3
      "0",                            # 4
      "0",                            # 5
      "0",                            # 6
      height.toString(),              # 7
      lastBlock.timestamp.toString(), # 8
      "0",                            # 9
      "0",                            # 10
      selfUnlockHeight.toString(),    # 11
      "0",                            # 12
      "0",                            # 13
      "NULL",                         # 14
      "0",                            # 15
      "0",                            # 16
      "0",                            # 17
      "0",                            # 18
      "",                             # 19
      inAsset                         # 20
  )
}

func finishSwapDATA(dataArray: List[String], price: Int, outNetAmount: Int, outFeeAmount: Int, randUnlockHeight: Int,
                    index: Int, withdrawTxId: String, outSurfAmt: Int, br: Int, basketData: String, inAsset: String) = {
  strSwapDATA(
      dataArray[sIdxSwapType],        # 1
      "FINISHED",                     # 2
      dataArray[sIdxInAmount],        # 3
      price.toString(),               # 4
      outNetAmount.toString(),        # 5
      outFeeAmount.toString(),        # 6
      dataArray[sIdxStartHeight],     # 7
      dataArray[sIdxStartTimestamp],  # 8
      height.toString(),              # 9
      lastBlock.timestamp.toString(), # 10
      dataArray[sIdxSelfUnlockHeight],# 11
      randUnlockHeight.toString(),    # 12
      index.toString(),               # 13
      withdrawTxId,                   # 14
      dataArray[sIdxMinRand],         # 15
      dataArray[sIdxMaxRand],         # 16
      outSurfAmt.toString(),          # 17
      br.toString(),                  # 18
      basketData,                     # 19
      inAsset                         # 20
  )
}

func swapDataFailOrREAD(userAddress: String, swapTxId: String) = {
  let swapKey = swapKEY(userAddress, swapTxId)
  getString(swapKey)
    .valueOrErrorMessage("no swap data for " + swapKey)
    .split_4C(SEP)
}

func applyFees(amountOutGross: Int, inAmtToSURF: Int, feePart: Int) = {
  let feeAmount = fraction(amountOutGross, feePart, MULT6)
  [amountOutGross - feeAmount, feeAmount]
}

# basket out: List[(assetId, outAmount, price, share)]
func applyFeesBasket(basketOut: List[(String, Int, Int, Int)]) = {
  let feePart = multiOutFeeREAD()
  func feeApplier(acc: List[String], item: (String, Int, Int, Int)) = {
    let feeAmount = fraction(item._2, feePart, MULT6)
    acc :+ makeString([
      item._1, # assetId
      item._3.toString(), # price
      (item._2 - feeAmount).toString(), # netAmount
      feeAmount.toString(),
      item._4.toString() # share
    ], LISTSEP)
  }
  let a = FOLD<10>(basketOut, [], feeApplier)
  makeString_2C(a, "_") # assetId:price:netAmount:feeAmount:share_ ...
}

func selectNode(unleaseAmount: Int) = {
    let amountToLease = wavesBalance(neutrinoContract).available - unleaseAmount - getReservedAmountForSponsorship()

    let oldLeased0 = getNumberByKey(getLeaseAmountKey(0))
    let newLeased0 = amountToLease + oldLeased0

    if (newLeased0 > 0) then newLeased0 else 0
}

func thisOnly(i: Invocation) = {
  if (i.caller != this) then {
    throw("Permission denied: this contract only allowed")
  } else true
}

# prepare list of actions to lease available waves or cancel lease in case of usdn2waves swap
func prepareUnleaseAndLease(unleaseAmount: Int) = {
    let newLeaseAmount  = selectNode(unleaseAmount)
    let nodeIndex       = 0

    if (newLeaseAmount > 0) then {
        # get rid of node1 leftovers
        let leaseIdKey1 = getLeaseIdKey(1)
        let oldLease1 = getBinary(leaseIdKey1)
        let unleaseOrEmpty1 = if (oldLease1.isDefined()) then [
          LeaseCancel(oldLease1.value()),
          DeleteEntry(leaseIdKey1),
          DeleteEntry(getLeaseAmountKey(1))
        ] else []

        let leaseIdKey = getLeaseIdKey(nodeIndex)
        let oldLease = getBinary(this, leaseIdKey)
        let unleaseOrEmpty = if (oldLease.isDefined()) then [LeaseCancel(oldLease.value())] else []
        let leaseAmountKey = getLeaseAmountKey(nodeIndex)
        let lease = Lease(getStakingNodeAddressByIndex(nodeIndex), newLeaseAmount)

        unleaseOrEmpty1 ++ unleaseOrEmpty ++ [
            lease,
            BinaryEntry(leaseIdKey, lcalc(lease)),
            IntegerEntry(leaseAmountKey, newLeaseAmount)]
    } else []
}

func readNodeInfo(nodeIdx: Int) = {
  let nodeAddress = getStakingNodeAddressByIndex(nodeIdx)
  let leasedAmtKEY = getLeaseAmountKey(nodeIdx)
  let leasedAmt = leasedAmtKEY.getNumberByKey()

  let leaseIdKEY = getLeaseIdKey(nodeIdx)
  let leaseId = this.getBinary(leaseIdKEY).value()

  (nodeAddress, leasedAmtKEY, leasedAmt, leaseIdKEY, leaseId)
}

# convenient method to avoid copy-paste
func LeasingRelatedActions(nodeAddr: Address, newAmount: Int, oldId: ByteVector, newIdKey: String, newAmtKey: String) = {
  let lease = Lease(nodeAddr, newAmount)
  [ LeaseCancel(oldId),
    lease,
    BinaryEntry(newIdKey, calculateLeaseId(lease)),
    IntegerEntry(newAmtKey, newAmount)]
}

#-------------------MAIN LOGIC----------------------

func commonSwap(swapType: String, pmtAmount: Int, inAsset: String, userAddressStr: String, txId58: String) = {
  let swapParamsSTRUCT = this.invoke("swapParamsByUserSYSREADONLY", [userAddressStr, 0], []).asSwapParamsSTRUCT()

  let tokenSwapLimitUsd = swapParamsSTRUCT._1
  let swapLimitSpent    = swapParamsSTRUCT._2
  let blcks2LmtReset    = swapParamsSTRUCT._3
  let usdnSwapLimitMax  = swapParamsSTRUCT._7

  let minSwapAmount         = minSwapAmountREAD(swapType, inAsset)
  let totalLockedByUser     = totalLockedByUserREAD(swapType, userAddressStr, inAsset)
  let nodeAddress           = getStakingNodeByIndex(0)
  let isSwapByNode          = nodeAddress == userAddressStr

  let balanceLockMaxInterval = if (isSwapByNode) then nodeBalanceLockIntervalREAD() else balanceLockIntervalREAD(swapType)
  let selfUnlockHeight       = height + balanceLockMaxInterval
  let pr = controlContract.getInteger(keyPriceByAsset(inAsset)).value()
  let swapUsdnVolume         = if (swapType == "outNeutrino") then pmtAmount.convertTokenToUsd(pr) else pmtAmount
  let swapLimitMax           = if (swapType == "outNeutrino") then tokenSwapLimitUsd else usdnSwapLimitMax

  if (pmtAmount < minSwapAmount) then minSwapAmountFAIL(swapType, minSwapAmount) else
  if (!isSwapByNode && swapLimitSpent > 0) then throw("You have exceeded swap limit! Next allowed swap height is " + (height + blcks2LmtReset).toString()) else
  if (!isSwapByNode && swapUsdnVolume > swapLimitMax) then throw("You have exceeded your swap limit! Requested: "+ toString(swapUsdnVolume) + ", available: " + toString(swapLimitMax)) else
  if (isBlocked) then emergencyShutdownFAIL() else  # see control.ride

  # during the high disproportion of basket tokens, it is possible that (1 + D - b^(dlog - w[i] + x[i])) goes negative
  # we should prevent such swaps
  let neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsREADONLY", [], []).asAnyList()
  let basketInfo = neutrinoMetrics[nMetricBasketInfo].asString() # assetIdStr:share6:price6:reserve8_ ...
  let weightedPrice = neutrinoMetrics[nMetricWeightedPrice].asInt()
  let out = convertBasketItemToNeutrino(pmtAmount, inAsset, basketInfo, weightedPrice) # [outGrossAmount, netAmount, feeAmount, multiplier]
  let maxFee = getInteger(maxFeeKey()).valueOrElse(DEFAULTMAXFEE)
  if (swapType == "outNeutrino" && out[3] < (MULT6 - maxFee)) then throw("Max allowed fee exceeded, multiplier = " + out[3].toString()) else

  let leasePart = if (swapType == "outNeutrino" && inAsset == "WAVES") then prepareUnleaseAndLease(0) else []

  ([
      IntegerEntry(keySwapUserSpentInPeriod(userAddressStr), swapUsdnVolume),
      IntegerEntry(keyUserLastSwapHeight(userAddressStr), height),
      IntegerEntry(totalLockedByUserKEY(swapType, userAddressStr, inAsset), totalLockedByUser + pmtAmount),
      IntegerEntry(getBalanceUnlockBlockKey(userAddressStr), selfUnlockHeight),
      StringEntry(
        swapKEY(userAddressStr, txId58),
        pendingSwapDATA(swapType, pmtAmount, selfUnlockHeight, inAsset))
    ] ++ leasePart, unit)
}

# surfFunctionREADONLY result array indices
let bFuncIdxSurf = 0
let bFuncIdxWaves = 1
let bFuncIdxUsdn = 2
let bFuncIdxReserveStart = 3
let bFuncIdxSupplyStart = 4
let bFuncIdxBRStart = 5
let bFuncIdxReserveEnd = 6
let bFuncIdxSupplyEnd = 7
let bFuncIdxBREnd = 8
let bFuncIdxRest = 9
let bFuncIdxWavesPrice = 10

# basket token to neutrino
func calcWithdrawT2U(inAmount: Int, inAsset: String, basketInfo: String, weightedPrice: Int) = {
  let outAmt = convertBasketItemToNeutrino(inAmount, inAsset, basketInfo, weightedPrice) # [outAmountGross, netAmount, feeAmount, multiplier]
  (
    outAmt[0],        # gross outAmount (fees are not applied yet)
    neutrinoAssetId,  # outAssetId is USDN
    0,                # part of inAmount that is converted into SURF to protect BR
    inAsset,          # inAssetId is WAVES
    0,                # amount to unlease
    weightedPrice,    # withdraw price
    inAmount,         # debug - part of inAmount that is swapped into out asset
    0,                # debug - max allowed usdn amount to reach BR protection level
    0,                # debug - part of inAmount that is used BEFORE reaching BR protection level
    0,                # debug - part of inAmount that is used AFTER reaching BR protection level
    [],               # dummy value
    [outAmt[1], outAmt[2]] # [netAmount, feeAmount]
  )
}

# basketInfo: assetIdStr:share6:price6:reserve8_ ...
func calcWithdrawU2Basket(usdnIn: Int, basketInfo: String, neutrinoSupply: Int) = {

  let outAmtGross = convertNeutrinoToBasket(usdnIn, basketInfo, neutrinoSupply) # (List[(assetId, outAmount, price, share)], wavesOutAmount, wavesPrice)
  (
    outAmtGross._2,             # LEGACY gross WAVES outAmount (fees are not applied yet)
    unit,                       # LEGACY waves_id
    0,                          # part of inAmount that is converted into SURF to protect BR
    neutrinoAssetId,            # inAssetId is USDN
    outAmtGross._2,             # WAVES amount to unlease
    outAmtGross._3,             # LEGACY withdraw WAVES price
    usdnIn,                     # debug - part of inAmount that is swapped into out assets
    neutrinoSupply,             # debug - max allowed usdn amount to reach BR protection level
    usdnIn,                     # debug - part of inAmount that is used BEFORE reaching BR protection level
    0,                          # debug - part of inAmount that is used AFTER reaching BR protection level
    outAmtGross._1,             # List[(assetId, outAmount, price, share)]
    []                          # dummy value
  )
}

func calcWithdraw(swapType: String, inAmount: Int, price: Int, neutrinoMetrics: List[Any], inAsset: String) = {
  let neutrinoSupply    = neutrinoMetrics[nMetricIdxUsdnSupply].asInt()
  let basketInfo        = neutrinoMetrics[nMetricBasketInfo].asString() # assetIdStr:share6:price6_ ...
  let weightedPrice = neutrinoMetrics[nMetricWeightedPrice].asInt()
  let outDataTuple =
    if (swapType == "outNeutrino") then calcWithdrawT2U(inAmount, inAsset, basketInfo, weightedPrice) else
    if (swapType == "outMulti") then calcWithdrawU2Basket(inAmount, basketInfo, neutrinoSupply)
    else throw("Unsupported swap type " + swapType)

  let outAmtGross       = outDataTuple._1 # grossAmount for outNeutrino
  let outAssetId        = outDataTuple._2 # neutrinoAssetId for outNeutrino
  let inAmtToSurfPart   = outDataTuple._3
  let inAssetId         = outDataTuple._4
  let unleaseAmt        = outDataTuple._5 # 0 for outNeutrino; WAVES outAmount for outMulti
  let withdrawPrice     = outDataTuple._6 # weightedPrice for outNeutrino
  let basketData        = outDataTuple._11 # List[(assetId, outAmount, price, share)] for outMulti
  let netFeeData        = outDataTuple._12 # [netAmount, feeAmount] for outNeutrino

  let outNetAmt = if (swapType == "outNeutrino") then netFeeData[0] else 0
  let outFeeAmt = if (swapType == "outNeutrino") then netFeeData[1] else 0

  let outSurfAmt = if (inAmtToSurfPart <= 0) then 0 else
    mathContract.invoke("surfFunctionREADONLY", [inAmtToSurfPart, inAssetId], []).asAnyList()[bFuncIdxSurf].asInt()

  let withdrawBasket = if (swapType == "outMulti") then applyFeesBasket(basketData) else "" # assetId:price:netAmount:feeAmount:share_ ...

  # WARNING: if u modify then need to check RestV2
  #   1         2           3             4               5           6         7             8              9
  (outNetAmt, outAssetId, outSurfAmt, inAmtToSurfPart, unleaseAmt, outFeeAmt, outAmtGross, withdrawPrice, withdrawBasket)
}

# governance contract
func keyApplyInProgress() = "%s__applyInProgress"
func keyProposalDataById(proposalId: Int) = "%s%d__proposalData__" + proposalId.toString()

# indices to access proposal data fields (static)
let govIdxTxIds = 9

# The transaction cannot be added to the blockchain if the timestamp value is more than 2 hours behind
# or 1.5 hours ahead of current block timestamp
func validateUpdate(tx: Transaction|Order) = {
    match(tx) {
        case o: Order => throw("Orders aren't allowed")
        case t: Transaction => {
            let txId = toBase58String(t.id)
            let proposalId = govContract.getInteger(keyApplyInProgress()).valueOrErrorMessage("Apply is not happening")
            let txList = govContract.getStringOrFail(keyProposalDataById(proposalId)).split(SEP)[govIdxTxIds].split(LISTSEP)
            if (!txList.indexOf(txId).isDefined()) then throw("Unknown txId: " + txId + " for proposalId=" + proposalId.toString()) else

            true
        }
    }
}

#-------------------Callable----------------------

@Callable(i)
func constructorV1(
  neutrinoAssetIdPrm: String,
  bondAssetIdPrm: String,
  auctionContractPrm: String,
  liquidationContractPrm: String,
  rpdContractPrm: String,
  nodeOracleProviderPubKeyPrm: String,
  balanceWavesLockIntervalPrm: Int,
  balanceNeutrinoLockIntervalPrm: Int,
  minWavesSwapAmountPrm: Int, # LEGACY
  minNeutrinoSwapAmountPrm: Int,
  neutrinoOutFeePartPrm: Int, # LEGACY, not used
  wavesOutFeePartPrm: Int) = { # LEGACY, not used

  strict checkCaller = i.thisOnly()
  if (i.payments.size() != 0) then throw("no payments allowed") else
  [
    StringEntry(NeutrinoAssetIdKey, neutrinoAssetIdPrm),
    StringEntry(BondAssetIdKey, bondAssetIdPrm),
    StringEntry(AuctionContractKey, auctionContractPrm), # ignored
    StringEntry(LiquidationContractKey, liquidationContractPrm), # ignored
    StringEntry(RPDContractKey, rpdContractPrm), #ignored
    StringEntry(NodeOracleProviderPubKeyKey, nodeOracleProviderPubKeyPrm),
    IntegerEntry(BalanceWavesLockIntervalKey, balanceWavesLockIntervalPrm),
    IntegerEntry(BalanceNeutrinoLockIntervalKey, balanceNeutrinoLockIntervalPrm),
    IntegerEntry(MinTokenSwapAmountKey("WAVES"), minWavesSwapAmountPrm),
    IntegerEntry(MinNeutrinoSwapAmountKey, minNeutrinoSwapAmountPrm),
    IntegerEntry(NeutrinoOutFeePartKey, neutrinoOutFeePartPrm),
    IntegerEntry(WavesOutFeePartKey, wavesOutFeePartPrm)
  ]
}

@Callable(i)
func constructorV2(mathContract: String, nsbtStakingContract: String, swapsTimeframeBlocks: Int) = {
  strict checkCaller = i.thisOnly()
  if (i.payments.size() != 0) then throw("no payments allowed") else
  [
    StringEntry(MathContractKey, mathContract),
    StringEntry(NsbtStakingContractKey, nsbtStakingContract),
    IntegerEntry(swapsTimeframeKEY(), swapsTimeframeBlocks)
  ]
}

# pass assetsWeightsMins in the form: ["WAVES_500000_00000001", "nextAssetId_500000_00000001"]
@Callable(i)
func constructorV3(assetsWeightsMins: List[String], dParam: Int, kParam: Int, bParam: Int, deltaParam: Int) = {
  strict checkCaller = i.thisOnly()
  if (i.payments.size() != 0) then throw("no payments allowed") else

  func prepare(acc: (List[String], List[IntegerEntry]), item: String) = {
    let parts = item.split("_")
    let assetId = parts[0]
    let weight = parts[1].parseIntValue()
    let minVal = parts[2].parseIntValue()
    (acc._1 :+ assetId, acc._2 :+ IntegerEntry(basketWeightByAssetKey(assetId), weight) :+ IntegerEntry(MinTokenSwapAmountKey(assetId), minVal))
  }
  let r = FOLD<10>(assetsWeightsMins, ([], []), prepare)

  r._2 # weights and minSwapAmounts
  :+ IntegerEntry(basketDKey(), dParam)
  :+ IntegerEntry(basketKKey(), kParam)
  :+ IntegerEntry(basketBKey(), bParam)
  :+ IntegerEntry(basketLogbDeltaKey(), log(deltaParam, 6, bParam, 6, 6, HALFUP))
  :+ StringEntry(basketAssetsKey(), makeString(r._1, SEP))
}

# Instant swap of basket token to XTN at the current price on the smart contract
# [called by user]
@Callable(i)
func swapTokenToNeutrino() = {
    if (isDisabledIssueXtn) then throw("XTN issue is disabled") else
    if (i.payments.size() != 1) then throw("swapTokenToNeutrino require only one payment") else
    let pmt = i.payments[0].value()
    # check allowed assets
    let basketAssets = getString(basketAssetsKey()).value() # WAVES__wxId__viresId__swopId__eggId__westId
    let pmtAssetIdStr = pmt.assetId.valueOrElse(WAVESID).toBase58String()
    if (!basketAssets.contains(pmtAssetIdStr)) then throw(pmtAssetIdStr + " is not one of basket tokens:" + basketAssets) else

    let userAddress = i.caller.toString()
    let txId58 = i.transactionId.toBase58String()

    # note: we need to save totalLocked BEFORE getting neutrinoMetrics, because payment is added to assetBalance
    let totalLocked = totalLockedREAD("outNeutrino", pmtAssetIdStr)
    let pmtAmount = pmt.amount
    strict saveTotalLocked = this.invoke("internalSaveInteger", [totalLockedKEY("outNeutrino", pmtAssetIdStr), totalLocked + pmtAmount], [])

    commonSwap("outNeutrino", pmtAmount, pmtAssetIdStr, userAddress, txId58)
}

# Swap request of Neutrino to multi-basket. After {balanceLockInterval} blocks, basket tokens will be available for withdrawal
# via {withdraw(account : String)} method at the prices actual on the time when {balanceLockInterval} is reached
# [called by user]
@Callable(i)
func swapNeutrinoToBasket() = {
    if (i.payments.size() != 1) then throw("swapNeutrinoToBasket require only one payment") else
    let pmt = i.payments[0].value()
    if (pmt.assetId != neutrinoAssetId) then throw("Only appropriate Neutrino tokens are allowed for swapping.") else

    let userAddress = i.caller.toString()
    let txId58 = i.transactionId.toBase58String()

    # note: we need to save totalLocked BEFORE getting neutrinoMetrics, because payment is added to assetBalance
    let neutrinoAssetIdStr = neutrinoAssetId.toBase58String()
    let totalLocked = totalLockedREAD("outMulti", neutrinoAssetIdStr)
    let pmtAmount = pmt.amount
    strict saveTotalLocked = this.invoke("internalSaveInteger", [totalLockedKEY("outMulti", neutrinoAssetIdStr), totalLocked + pmtAmount], [])

    commonSwap("outMulti", pmt.amount, neutrinoAssetIdStr, userAddress, txId58)
}

@Callable(i)
func internalSaveInteger(key: String, amount: Int) = {
  if (i.caller != this) then throw("internalSaveInteger is not public method") else
  [IntegerEntry(key, amount)]
}

# Withdraw neutrino or multi-basket from smart contract on behalf of account,
# after swap request has reached {balanceLockInterval} height
# at the price that is current at the time when {balanceLockInterval} is reached
@Callable(i)
func withdraw(account: String, index: Int, swapTxId: String) = {
    let txId = i.transactionId.toBase58String()
    if (i.payments.size() != 0) then throw("no payments allowed") else

    let neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsREADONLY", [], []).asAnyList()
    let BR = neutrinoMetrics[nMetricIdxBR].asInt()

    let userAddress = addressFromStringValue(account)

    let dataArray         = swapDataFailOrREAD(account, swapTxId)
    let selfUnlockHeight  = dataArray[sIdxSelfUnlockHeight].parseIntValue()
    let swapType          = dataArray[sIdxSwapType]
    let inAmount          = dataArray[sIdxInAmount].parseIntValue()
    let swapStatus        = dataArray[sIdxStatus]
    let startHeight       = dataArray[sIdxStartHeight].parseIntValue()
    let inAsset           = dataArray[sIdxInAsset]

    let totalLocked       = totalLockedREAD(swapType, inAsset)
    let totalLockedByUser = totalLockedByUserREAD(swapType, account, inAsset)

    let unlockHeight = selfUnlockHeight

    let indexHeight = getHeightPriceByIndex(index)
    let prevIndexHeight = getHeightPriceByIndex(index-1)
    let priceByIndex = getPriceHistory(indexHeight)

    if (isBlocked) then emergencyShutdownFAIL() else
    if (swapStatus != "PENDING") then throw("swap has been already processed") else
    if (unlockHeight > height) then throw("please wait for: " + toString(unlockHeight) + " block height to withdraw funds") else
    if (index > priceIndex
          || indexHeight < unlockHeight
          || (prevIndexHeight != 0 && unlockHeight <= prevIndexHeight)) then priceIndexFAIL(index, priceIndex, indexHeight, unlockHeight, prevIndexHeight) else

    let withdrawTuple = calcWithdraw(swapType, inAmount, priceByIndex, neutrinoMetrics, inAsset)
    let outNetAmount    = withdrawTuple._1 # for outNeutrino
    let outAssetId      = withdrawTuple._2 # neutrinoAssetId for outNeutrino
    let outSurfAmt      = withdrawTuple._3 # LEGACY, =0
    #let inAmtToSurfPart = withdrawTuple._4
    let unleaseAmt      = withdrawTuple._5 # 0 for outNeutrino; WAVES outAmount for outMulti
    let outFeeAmount    = withdrawTuple._6 # for outNeutrino
    let outAmtGross     = withdrawTuple._7 # for outNeutrino
    let withdrawPrice   = withdrawTuple._8 # weightedPrice for outNeutrino
    let withdrawBasket  = withdrawTuple._9 # assetId:price:netAmount:feeAmount:share_ ...

    if (swapType == "outNeutrino" && outAmtGross <= 0) then throw("balance equals zero") else

    strict surfCondition = if (outSurfAmt > 0) then {
       strict issueResult = auctionContract.invoke("issueSurf", [outSurfAmt, account], [])
       0
    } else 0

    strict unleaseInvOrEmpty = this.invoke("internalUnleaseAndLease", [unleaseAmt], [])
    let gnsbtData = gnsbtControllerContract.invoke("gnsbtInfoSYSREADONLY", ["", 0, 0], []).asAnyList()
    let gnsbtAmtTotal           = gnsbtData[1].asInt()
    let gnsbtAmtFromSurfTotal   = gnsbtData[3].asAnyList()[3].asInt()

    let commonActions = [
        IntegerEntry(totalLockedByUserKEY(swapType, account, inAsset), totalLockedByUser - inAmount),
        IntegerEntry(totalLockedKEY(swapType, inAsset), totalLocked - inAmount),
        StringEntry(
          swapKEY(account, swapTxId),
          finishSwapDATA(dataArray, withdrawPrice, outNetAmount, outFeeAmount, unlockHeight, index, txId, outSurfAmt, BR, withdrawBasket, inAsset))
      ]

    func deposits(surfFees: Int, nsbtFees: Int, surfPayments: List[AttachedPayment], nsbtPayments: List[AttachedPayment]) = {
      let surfDeposit = if (surfFees > 0) then surfStakingContract.invoke("deposit", [], surfPayments).asInt() else 0
      let nsbtDeposit = if (nsbtFees > 0) then nsbtStakingContract.invoke("deposit", [], nsbtPayments).asInt() else 0
      surfDeposit + nsbtDeposit
    }

    func divideFees(feeAmount: Int) = {
      let surfAmt1 = if (gnsbtAmtTotal != 0) then fraction(feeAmount, gnsbtAmtFromSurfTotal, gnsbtAmtTotal) else 0
      let surfAmt2 = if (gnsbtAmtTotal != 0) then fraction(feeAmount, MULT6 - BR, MULT6) else 0
      let surfAmt = max([surfAmt1, surfAmt2])
      let nsbtAmt = feeAmount - surfAmt
      [surfAmt, nsbtAmt]
    }

    let transfers = if (swapType == "outMulti") then {
      let basket = split_4C(withdrawBasket, "_")

      func looper(acc: (List[ScriptTransfer], List[AttachedPayment], List[AttachedPayment], Int, Int), item: String) = {
        let it = item.split(LISTSEP) # assetId:price:netAmount:feeAmount:share
        let tempAssetId = it[0].fromBase58String()
        let assetId = if (tempAssetId == WAVESID) then unit else tempAssetId
        let netAmount = it[2].parseIntValue()
        let feeAmount = it[3].parseIntValue()
        let fees = divideFees(feeAmount)
        ( acc._1 :+ ScriptTransfer(userAddress, netAmount, assetId),
          acc._2 :+ AttachedPayment(assetId, fees[0]), # payments list for surf_staking contract
          acc._3 :+ AttachedPayment(assetId, fees[1]), # payments list for nsbt_staking contract
          acc._4 + fees[0], # total fees for surf_staking contract
          acc._5 + fees[1] ) # total fees for nsbt_staking contract
      }
      let r = FOLD<10>(basket, ([], [], [], 0, 0), looper)

      let depoResult = deposits(r._4, r._5, r._2, r._3)
      (r._1, depoResult)
    } else { # swap type == outNeutrino
      let fees = divideFees(outFeeAmount)

      let depoResult = deposits(fees[0], fees[1], [AttachedPayment(outAssetId, fees[0])], [AttachedPayment(outAssetId, fees[1])])
      ([ScriptTransfer(userAddress, outNetAmount, outAssetId)], depoResult)
    }
    (commonActions ++ transfers._1, transfers._2)
}

@Callable(i)
func internalUnleaseAndLease(unleaseAmount: Int) = {
  if (i.caller != this) then throw("internalUnleaseAndLease is not public method") else
  prepareUnleaseAndLease(unleaseAmount)
}

# Callback for auction contract to transfer USDN to user
@Callable(i)
func transferUsdnToUser(amount: Int, addr: String) = {
    if (i.caller != auctionContract) then throw("Only auction contract is authorized") else

    [ScriptTransfer(addressFromStringValue(addr), amount, neutrinoAssetId)]
}

# Accept waves from auction after buyNsbt/buySurf to lease them immediately
# also from governance after creating new voting
@Callable(i)
func acceptWaves() = {
    if (i.caller != auctionContract && i.caller != govContract)
        then throw("Currently only auction and governance contracts are allowed to call")
    else
        (prepareUnleaseAndLease(0), "success")
}

@Callable(i)
func approveLeasings(nListS: String, groupNum: Int, lAmt: Int) = {
  let nIdxs = [0, 1, 2, 3, 4, 5, 6, 7]

  let mngPubS = getString("%s%s__cfg__leasingManagerPub").valueOrElse("7AUMX54ukYMYvPmma7yoFf5NjZhs4Bu5nz3Ez9EV8sur")
  let mngPub = mngPubS.fromBase58String()

  let nodeRegAddrStr = getString("%s%s__cfg__nodesRegistryAddress").valueOrElse("3P9vKqQKjUdmpXAfiWau8krREYAY1Xr69pE")
  let nodeRegAddr = nodeRegAddrStr.addressFromStringValue()

  let lGroupNodeListKEY = getLeaseGroupNodeListKey(groupNum)
  let lGrNodeOpt = this.getString(lGroupNodeListKEY)
  if (lGrNodeOpt.isDefined()) then throw("group " + groupNum.toString() + " already initialized") else

  let nList = nListS.split(SEP)
  let expCount = nIdxs.size()

  if (i.callerPublicKey != mngPub) then throw("approveLeasings not authorized") else

  let (nAddr0, lAmtKEY0, lAmt0, lIdKEY0, lId0) = readNodeInfo(0)

  let newL0 = Lease(nAddr0, lAmt0 - lAmt * expCount)

  strict validation = nodeRegAddr.invoke("validateAndApproveLeasings", [nListS], [])

  func forEachNodeValidateAndGenerateLease(a: List[Lease|BinaryEntry|IntegerEntry], i: Int) = {
    let node = nList[i]
    let la = Lease(node.addressFromStringValue(), lAmt)
    a++[la,
        BinaryEntry(getLeaseIdByAddressKey(node), lcalc(la)),
        IntegerEntry(getLeaseAmountByAddressKey(node), lAmt)]
  }

  [StringEntry(lGroupNodeListKEY, nListS),
    BinaryEntry(lIdKEY0, lcalc(newL0)),
    IntegerEntry(lAmtKEY0, newL0.amount),
    LeaseCancel(lId0),
    newL0
  ]
    ++ FOLD<8>(nIdxs, [], forEachNodeValidateAndGenerateLease)
}

# 10 groups, up to 8 nodes in the group
# amount: waves amt to take from community nodes in a given group
@Callable(i)
func rebalanceLeasings(amount: Int, groupNum: Int) = {
  let mngPubS = getString("%s%s__cfg__leasingManagerPub").valueOrElse("7AUMX54ukYMYvPmma7yoFf5NjZhs4Bu5nz3Ez9EV8sur")
  let mngPub = mngPubS.fromBase58String()
  if (i.callerPublicKey != mngPub) then throw("rebalanceLeasings not authorized") else

  let lGroupNodeListKEY = getLeaseGroupNodeListKey(groupNum)
  let nList = this.getStringOrFail(lGroupNodeListKEY).split(SEP)
  if (nList.size() < 1) then throw("Empty group " + groupNum.toString()) else

  let unleaseAmt = amount / nList.size() + 1
  let (nAddr0, lAmtKEY0, lAmt0, lIdKEY0, lId0) = readNodeInfo(0)

  func forEachNodeDoUnlease(a: List[LeaseCancel|Lease|BinaryEntry|IntegerEntry], node: String) = {
    let lIdKEY = getLeaseIdByAddressKey(node)
    let lId = this.getBinaryValue(lIdKEY) # old leaseId
    let lAmtKEY = getLeaseAmountByAddressKey(node)
    let lAmt = this.getIntegerValue(lAmtKEY) # old leasedAmount
    a ++ LeasingRelatedActions(addressFromStringValue(node), lAmt - unleaseAmt, lId, lIdKEY, lAmtKEY)
  }

  FOLD<8>(nList, [], forEachNodeDoUnlease)
    ++ LeasingRelatedActions(nAddr0, lAmt0 + unleaseAmt * nList.size(), lId0, lIdKEY0, lAmtKEY0)
}

# READONLY methods
@Callable(i)
func swapParamsByUserSYSREADONLY(userAddressStr: String, gnsbtDiff: Int) = {
  let gnsbtData = gnsbtControllerContract.invoke("gnsbtInfoSYSREADONLY", [userAddressStr, 0, 0], []).asAnyList()

  let gnsbtAmt      = gnsbtData[0].asInt() + gnsbtDiff
  let gnsbtAmtTotal = gnsbtData[1].asInt() + gnsbtDiff

  let swapLimitData = mathContract.invoke("calcSwapLimitREADONLY", [gnsbtAmt], []).asAnyList()
  let tokenSwapLimitInUsdMax = swapLimitData[0].asInt()
  let usdnSwapLimitMax        = swapLimitData[2].asInt()

  let lastSwapHeight = this.getInteger(keyUserLastSwapHeight(userAddressStr)).valueOrElse(0)
  let swapLimitTimelifeBlocks = swapsTimeframeREAD()
  let passedBlocksAfterLastSwap = height - lastSwapHeight
  let isSwapTimelifeNew = passedBlocksAfterLastSwap >= swapLimitTimelifeBlocks
  let swapLimitSpentInUsdn = if (isSwapTimelifeNew) then 0 else this.getInteger(keySwapUserSpentInPeriod(userAddressStr)).valueOrElse(0)
  let blcks2LmtReset = if (isSwapTimelifeNew) then 0 else swapLimitTimelifeBlocks - passedBlocksAfterLastSwap

  # WARNING if you change returned value - MUST have to change "asSwapParamsSTRUCT" function
  ([], (tokenSwapLimitInUsdMax, swapLimitSpentInUsdn, blcks2LmtReset, gnsbtAmt, gnsbtAmtTotal, 0, usdnSwapLimitMax))
}

@Callable(i)
func calcWithdrawResultSYSREADONLY(swapType: String, inAmount: Int, price: Int, inAsset: String) = {
  let neutrinoMetrics = mathContract.invoke("calcNeutinoMetricsREADONLY", [], []).asAnyList()
  ([], calcWithdraw(swapType, inAmount, price, neutrinoMetrics, inAsset))
}

@Callable(i)
func replaceCommunityNode(oldAddrStr: String, newAddrStr: String, groupNum: Int, penaltyAmount: Int) = {
  let mngPubS = getString("%s%s__cfg__leasingManagerPub").valueOrElse("7AUMX54ukYMYvPmma7yoFf5NjZhs4Bu5nz3Ez9EV8sur")
  let mngPub = mngPubS.fromBase58String()
  if (i.callerPublicKey != mngPub) then throw("replaceCommunityNode not authorized") else

  let groupKey = getLeaseGroupNodeListKey(groupNum)
  let groupNodeListS = this.getStringOrFail(groupKey)
  if (!groupNodeListS.contains(oldAddrStr)) then throw("Group " + groupNum.toString() + " does not contain address " + oldAddrStr) else

  strict doReplace = nodeRegistryContract.invoke("replaceApprovedNode", [oldAddrStr, newAddrStr, groupNum, penaltyAmount], [])

  let oldLeaseIdKey = getLeaseIdByAddressKey(oldAddrStr)
  let oldLeaseAmtKey = getLeaseAmountByAddressKey(oldAddrStr)
  let leaseAmt = getIntegerValue(oldLeaseAmtKey)
  let newLeaseIdKey = getLeaseIdByAddressKey(newAddrStr)
  let newLeaseAmtKey = getLeaseAmountByAddressKey(newAddrStr)
  let updatedGroupNodeListS = groupNodeListS.split(oldAddrStr).makeString(newAddrStr)

  ([DeleteEntry(oldLeaseIdKey), 
    DeleteEntry(oldLeaseAmtKey), 
    StringEntry(groupKey, updatedGroupNodeListS)]
    ++ LeasingRelatedActions(addressFromStringValue(newAddrStr), leaseAmt, getBinaryValue(oldLeaseIdKey), newLeaseIdKey, newLeaseAmtKey)
  , unit)
}

@Callable(i)
func removeCommunityNode(oldAddrStr: String, groupNum: Int, penaltyAmount: Int) = {
  let mngPubS = getString("%s%s__cfg__leasingManagerPub").valueOrElse("7AUMX54ukYMYvPmma7yoFf5NjZhs4Bu5nz3Ez9EV8sur")
  let mngPub = mngPubS.fromBase58String()
  if (i.callerPublicKey != mngPub) then throw("removeCommunityNode not authorized") else

  let groupKey = getLeaseGroupNodeListKey(groupNum)
  let groupNodeListS = this.getStringOrFail(groupKey)
  if (!groupNodeListS.contains(oldAddrStr)) then throw("Group " + groupNum.toString() + " does not contain address " + oldAddrStr) else

  strict doRemove = nodeRegistryContract.invoke("removeApprovedNode", [oldAddrStr, penaltyAmount], [])

  let oldLeaseIdKey = getLeaseIdByAddressKey(oldAddrStr)
  let oldLeaseAmtKey = getLeaseAmountByAddressKey(oldAddrStr)
  let leaseAmt = getIntegerValue(oldLeaseAmtKey)

  let (nAddr0, lAmtKEY0, lAmt0, lIdKEY0, lId0) = readNodeInfo(0) # (nodeAddress, leasedAmtKEY, leasedAmt, leaseIdKEY, leaseId)
  let updatedGroupNodeListS = removeFromListStr(groupNodeListS, SEP, oldAddrStr)

  ([DeleteEntry(oldLeaseIdKey),
    DeleteEntry(oldLeaseAmtKey),
    StringEntry(groupKey, updatedGroupNodeListS),
    LeaseCancel(lId0)] 
    ++ LeasingRelatedActions(nAddr0, lAmt0 + leaseAmt, getBinaryValue(oldLeaseIdKey), lIdKEY0, lAmtKEY0)
   , unit)
}

@Verifier(tx)
func verify() = {
    let pubKeyAdminsListStr = makeString([
        "GJdLSaLiv5K7xuejac8mcRcHoyo3dPrESrvktG3a6MAR",
        "EYwZmURd5KKaQRBjsVa6g8DPisFoS6SovRJtFiL5gMHU",
        "DtmAfuDdCrHK8spdAeAYzq6MsZegeD9gnsrpuTRkCbVA",
        "5WRXFSjwcTbNfKcJs8ZqXmSSWYsSVJUtMvMqZj5hH4Nc"
    ], SEP)

    let pubKeyAdminsList = controlContract.getString("%s__multisig")
          .valueOrElse(pubKeyAdminsListStr)
          .split(SEP)

    let count =
        (if(sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String(pubKeyAdminsList[0]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[1], fromBase58String(pubKeyAdminsList[1]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[2], fromBase58String(pubKeyAdminsList[2]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[3], fromBase58String(pubKeyAdminsList[3]))) then 2 else 0)

    if (isBlocked && 
      controlContract.getStringValue("is_blocked_caller") == govContract.toString()) then validateUpdate(tx) else {
        match tx {
            case sponsorTx: SponsorFeeTransaction =>
                checkIsValidMinSponsoredFee(sponsorTx) && count >= 3
            case _ => 
                count >= 3
        }
    }
}
